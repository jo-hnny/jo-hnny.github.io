<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>编程 on 冷宫</title><link>https://jo-hnny.github.io/categories/%E7%BC%96%E7%A8%8B/</link><description>Recent content in 编程 on 冷宫</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 11 Oct 2021 16:11:59 +0800</lastBuildDate><atom:link href="https://jo-hnny.github.io/categories/%E7%BC%96%E7%A8%8B/index.xml" rel="self" type="application/rss+xml"/><item><title>Github Page 自动化部署action</title><link>https://jo-hnny.github.io/p/github-page-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2action/</link><pubDate>Mon, 11 Oct 2021 16:11:59 +0800</pubDate><guid>https://jo-hnny.github.io/p/github-page-%E8%87%AA%E5%8A%A8%E5%8C%96%E9%83%A8%E7%BD%B2action/</guid><description>记录一下我常用的一套 github-page 自动化部署 actions name:CIon:pushjobs:deploy:runs-on:ubuntu-18.04steps:- name:Git checkoutuses:actions/checkout@v2- name:Setup NodeJSuses:actions/setup-node@v2with:node-version:&amp;#34;14&amp;#34;- name:Buildrun:|npm install npm run build- name:Deployuses:peaceiris/actions-gh-pages@v3with:personal_token:${{ secrets.TOKEN }}publish_dir:./dist其中 secrets.TOKEN 为 自己创建的 Personal access tokens,创建成功之后将其添加到目标项目的 Settings/secrets 下</description></item><item><title>Husky@v7使用指南</title><link>https://jo-hnny.github.io/p/huskyv7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</link><pubDate>Tue, 06 Jul 2021 14:24:51 +0800</pubDate><guid>https://jo-hnny.github.io/p/huskyv7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/</guid><description>为什么有这篇文章 最近我为开源项目 tkestack 的前端控制台部分添加了对 commit 的 lint，在添加过程中遇到了一些困难和疑惑，在此记录一下
v4 配置方式 安装 husky npm i husky -D 添加配置 在 package.json 中添加如下配置
//package.json &amp;#34;lint-staged&amp;#34;: { &amp;#34;./**/*.{ts,tsx,js,jsx}&amp;#34;: [ &amp;#34;eslint&amp;#34;, &amp;#34;prettier --write&amp;#34; ] }, &amp;#34;husky&amp;#34;: { &amp;#34;hooks&amp;#34;: { &amp;#34;pre-commit&amp;#34;: &amp;#34;lint-staged&amp;#34; } }, 或者添加.huskyrc 文件
// .huskyrc { &amp;#34;hooks&amp;#34;: { &amp;#34;pre-commit&amp;#34;: &amp;#34;lint-staged&amp;#34; } } v6+ 配置方式 第一次使用，按照 husky doc 进行配置
安装 husky npm i husky -D 开启 Git hooks npx husky install 执行到这里，我得到一个错误
npx husky install .</description></item><item><title>ZSH配置指南</title><link>https://jo-hnny.github.io/p/zsh%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 04 Jan 2021 10:39:16 +0800</pubDate><guid>https://jo-hnny.github.io/p/zsh%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</guid><description>图摄于西湖
本文以 ubuntu18.0.4 为例
安装 ZSH sudo apt-get install zsh
设置 ZSH 为默认 shell chsh -s $(which zsh)
安装ohmyzsh sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
但是由于网络的问题，我总是遇到这个错误：
Failed to connect to raw.github.com port 443: Connection refused
所以我换了个方法，先把 ohmyzsh 的 GitHub 仓库克隆下来,然后再安装：
git clone https://github.com/ohmyzsh/ohmyzsh.git sh -c ohmyzsh/tools/install.sh zsh 插件和主题配置 安装spaceship主题 git clone https://github.com/denysdovhan/spaceship-prompt.git &amp;quot;$ZSH_CUSTOM/themes/spaceship-prompt&amp;quot; --depth=1 ln -s &amp;quot;$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme&amp;quot; &amp;quot;$ZSH_CUSTOM/themes/spaceship.zsh-theme&amp;quot; 安装zsh-autosuggestions插件 这个插件主要作用是记录下历史命令，在你输入一部分时自动提示补全
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
安装zsh-syntax-highlighting插件 这个插件主要功能是高亮你输入的正确的命令</description></item><item><title>二分查找</title><link>https://jo-hnny.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 23 Dec 2020 11:55:21 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>循环 function find2(data: number[], n) { let low = 0; let higth = data.length; let middleIndex = low + Math.floor((higth - low) / 2); let middleValue = data[middleIndex]; while (n !== middleValue) { if (higth &amp;lt;= low) { return -1; } if (n &amp;lt; middleValue) { higth = middleIndex; } else { low = middleIndex; } middleIndex = low + Math.floor((higth - low) / 2); middleValue = data[middleIndex]; } return middleIndex; } // test const array = [.</description></item><item><title>在scss和css_module环境中切换主题</title><link>https://jo-hnny.github.io/p/%E5%9C%A8scss%E5%92%8Ccss_module%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/</link><pubDate>Wed, 23 Dec 2020 11:41:47 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%9C%A8scss%E5%92%8Ccss_module%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/</guid><description>今天尝试在项目中完成切换主题的功能，目前已经实现，故做个记录 新建一个 scss 文件保存颜色配置，例如： // themes.scss $themes: ( light: ( main: #364f6b, second: #3fc1c9, third: #f5f5f5, fourth: #fc5185, ), dark: ( main: #e4f9f5, second: #30e3ca, third: #11999e, fourth: #40514e, ), ); 新建另一个 scss 文件，创建 mixin： // themify.scss @import &amp;#34;./themes.scss&amp;#34;; @mixinthemify($themes: $themes) { @each $theme, $map in $themes { :global(.theme-#{$theme}) &amp;amp; { $theme-map: () !global; @each $key, $submap in $map { $value: map-get(map-get($themes, $theme), &amp;#34;#{$key}&amp;#34;); $theme-map: map-merge( $theme-map, ( $key: $value, ) ) !</description></item><item><title>React项目中同时添加css Modules与普通class</title><link>https://jo-hnny.github.io/p/react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0css-modules%E4%B8%8E%E6%99%AE%E9%80%9Aclass/</link><pubDate>Wed, 18 Sep 2019 21:16:58 +0800</pubDate><guid>https://jo-hnny.github.io/p/react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0css-modules%E4%B8%8E%E6%99%AE%E9%80%9Aclass/</guid><description>当我在 react 项目中为一个元素添加了 css modules 的样式，但是由于我要使用 iconfont，必须在元素上添加一个名为 iconfont 的 class 名称，搜来搜去也没找到什么优雅的实现，那就按照 class 的本质实现吧，class 本质就是一个字符串，多个 class 名由空格分割，故:
public render() { return ( &amp;lt;div className={`${styles.uploader}iconfont`}&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; className={styles[&amp;#39;file-input&amp;#39;]} /&amp;gt; &amp;amp;#xe7da; &amp;lt;/div&amp;gt; ) } 今天新发现一个库classnames可以很好的解决这个问题,使用如下：
import classNames from &amp;#34;classnames&amp;#34;; import React, { Component } from &amp;#34;react&amp;#34;; import styles from &amp;#34;./index.module.scss&amp;#34;; export default class extends Component { public uploadImage = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { console.log(e.target.files); }; public render() { return ( &amp;lt;div className={classNames(&amp;#34;iconfont&amp;#34;, styles.uploader)}&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; accept=&amp;#34;image/png, image/jpeg&amp;#34; multiple={true} className={styles[&amp;#34;file-input&amp;#34;]} onChange={this.</description></item><item><title>(译)React+Redux+Typescript</title><link>https://jo-hnny.github.io/p/%E8%AF%91react-redux-typescript/</link><pubDate>Wed, 18 Sep 2019 21:14:23 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E8%AF%91react-redux-typescript/</guid><description>React + Redux + TypeScript - 成为更好的前端（教程） 我在开始构建 React 应用，但是我希望我的应用有一个好的构建方式，这是我在 Medium 上看到的一篇不错的教程，为了方便我理解，顺便学英语，翻译在此，英语版的可以点击查看原文
构建一个满意的 React 应用程序是比较困难的（主要是比较难找到一份 React 的最佳实践，这点 Angular 还是很优秀的，但是我喜欢 jsx）。当你掌握了 VirtualDOM 的概念以及框架是如何工作的时候，你会很快意识到单单使用 React 本身不足以构建比 TODO-LIST 更大的应用。这个时候你开始学习使用类似 Flux 这样的 store 架构，比如说应用最广泛的 Redux，很快你会沉没在 actions 和 reducers 中，并且你开始在保持数据分离上遇到更多的困难，这听起来你是不是很熟悉？
在本文中，我将介绍如何构建一个可扩展的应用程序，再看接下里的内容之前，我希望你已经明白 React 是如何工作的，并且对 Flux 或者 Redux 有一点了解。
本文是我由 2018 年 7 月 25 日 SwingDev 在 microConf 大会上的演讲整理而成的书面版本。更多的信息可以点击microconf.io.
为什么要使用 Store 如果你已经使用 React 编写过一个小的应用程序，那么你会发现好像少了些什么。
假设我们正在创建由两个主要组件构成的简单应用：包含所有电子邮件列表的侧边栏组件和显示当前所选电子邮件内容的内容组件。单击侧边栏的元素时，我们使用路由来更改页面的 URL 并将电子邮件的 ID 放在其中。但是我们需要在内容组件中获取到电子邮件的具体内容，即使侧边栏组件中已经存在该数据，我们依然无法在他的兄弟组件中获取到该数据。
你也许已经想到，我们可以把数据移动到父组件（包含了侧边栏组件和内容组件）来解决这个问题，但是这会产生许多潜在的问题和瓶颈。首先我们需要从父组件传递数据到子组件，并且将所有数据处理逻辑放到父组件中（例如删除邮件）。
使用 Flux 架构有助于解决这两个问题，它抽象了存储数据和操作数据（即 actions）的逻辑，并且提供了简单的方法将数据传递给需要它的组件（即 Redux 中的 connect 函数）。</description></item></channel></rss>