<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on 冷宫</title><link>https://jo-hnny.github.io/post/</link><description>Recent content in Posts on 冷宫</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Mon, 04 Jan 2021 10:39:16 +0800</lastBuildDate><atom:link href="https://jo-hnny.github.io/post/index.xml" rel="self" type="application/rss+xml"/><item><title>ZSH配置指南</title><link>https://jo-hnny.github.io/p/zsh%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</link><pubDate>Mon, 04 Jan 2021 10:39:16 +0800</pubDate><guid>https://jo-hnny.github.io/p/zsh%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/</guid><description>图摄于西湖
本文以 ubuntu18.0.4 为例
安装 ZSH sudo apt-get install zsh
设置 ZSH 为默认 shell chsh -s $(which zsh)
安装ohmyzsh sh -c &amp;quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&amp;quot;
但是由于网络的问题，我总是遇到这个错误：
Failed to connect to raw.github.com port 443: Connection refused
所以我换了个方法，先把 ohmyzsh 的 GitHub 仓库克隆下来,然后再安装：
git clone https://github.com/ohmyzsh/ohmyzsh.git sh -c ohmyzsh/tools/install.sh zsh 插件和主题配置 安装spaceship主题 git clone https://github.com/denysdovhan/spaceship-prompt.git &amp;quot;$ZSH_CUSTOM/themes/spaceship-prompt&amp;quot; --depth=1 ln -s &amp;quot;$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme&amp;quot; &amp;quot;$ZSH_CUSTOM/themes/spaceship.zsh-theme&amp;quot; 安装zsh-autosuggestions插件 这个插件主要作用是记录下历史命令，在你输入一部分时自动提示补全
git clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions
安装zsh-syntax-highlighting插件 这个插件主要功能是高亮你输入的正确的命令</description></item><item><title>Happy Birthday With New Year</title><link>https://jo-hnny.github.io/p/happy-birthday-with-new-year/</link><pubDate>Mon, 28 Dec 2020 11:08:45 +0800</pubDate><guid>https://jo-hnny.github.io/p/happy-birthday-with-new-year/</guid><description>又长了一岁 越来越没办法忽视自己的年龄，但是每个人的路注定是不一样的，也许我的注定坎坷一点，加油， better than better
祝大家新年新气象 Happy New Year Rabbit Girl Cat Girl
插图来自最近喜欢的日本画师 天凪える .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen-Sans,Ubuntu,Cantarell,"Helvetica Neue",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; } 🍼お知らせ🍼
年賀状の再販することになりました💌
すでに販売スタートしてます🐾
今回はお名前とメッセージはなしで直筆サインのみですのでご注意ください！！
12/30 22時までの販売なのでよろしくお願いしますにゃんฅ( ´ ^ ` ฅ)https://t.co/wbBHAB0ZRJ #booth_pm pic.twitter.com/9SZ7bMdy2l
&amp;mdash; 天凪える🍼🐾 (@amanagiel) December 27, 2020</description></item><item><title>又折腾博客啦</title><link>https://jo-hnny.github.io/p/%E5%8F%88%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E5%95%A6/</link><pubDate>Wed, 23 Dec 2020 17:01:19 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%8F%88%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E5%95%A6/</guid><description>又折腾了 之前下定决心不折腾的，就只是用 github pages 默认的主题，最简单的方式，但是从那之后很久都没有打开过博客了，好像兴趣丧失了，这次正好看到这个主题很喜欢，就又折=折腾一下，不过 actions 部署好了，后面写博客也就很简单啦！
年终了 今年不出意料的过的很快，但是也发生了很多事情，从杭州撤了回来，其实心里感觉是自己认输了，躺平了，不挣扎了，但是想想对自己来说应该是最好的选择了，之前那样的状态，不知道能不能活到现在呢！
新年期待 攒钱
变得更好，从内到外
矫正的事情去医院看看方案 近视的事情，尚未想好，不戴眼镜自然是绝佳的 脸上的疤也可以去咨询一下，最好皮肤状态稳定 心能静下来 多参加户外活到 把想写的开源项目写了
图片的 - 先写这个 视频的 - 慢慢来 工作上
学习一下 go 学习 k8s 相关 感情
&amp;hellip; 过年要做的事情
给爸妈买套衣服吧，毕业也好几年了，还没给他们买过</description></item><item><title>二分查找</title><link>https://jo-hnny.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</link><pubDate>Wed, 23 Dec 2020 11:55:21 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</guid><description>循环 function find2(data: number[], n) { let low = 0; let higth = data.length; let middleIndex = low + Math.floor((higth - low) / 2); let middleValue = data[middleIndex]; while (n !== middleValue) { if (higth &amp;lt;= low) { return -1; } if (n &amp;lt; middleValue) { higth = middleIndex; } else { low = middleIndex; } middleIndex = low + Math.floor((higth - low) / 2); middleValue = data[middleIndex]; } return middleIndex; } // test const array = [.</description></item><item><title>在scss和css_module环境中切换主题</title><link>https://jo-hnny.github.io/p/%E5%9C%A8scss%E5%92%8Ccss_module%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/</link><pubDate>Wed, 23 Dec 2020 11:41:47 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%9C%A8scss%E5%92%8Ccss_module%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/</guid><description>今天尝试在项目中完成切换主题的功能，目前已经实现，故做个记录 新建一个 scss 文件保存颜色配置，例如： // themes.scss $themes: ( light: ( main: #364f6b, second: #3fc1c9, third: #f5f5f5, fourth: #fc5185, ), dark: ( main: #e4f9f5, second: #30e3ca, third: #11999e, fourth: #40514e, ), ); 新建另一个 scss 文件，创建 mixin： // themify.scss @import &amp;#34;./themes.scss&amp;#34;; @mixinthemify($themes: $themes) { @each $theme, $map in $themes { :global(.theme-#{$theme}) &amp;amp; { $theme-map: () !global; @each $key, $submap in $map { $value: map-get(map-get($themes, $theme), &amp;#34;#{$key}&amp;#34;); $theme-map: map-merge( $theme-map, ( $key: $value, ) ) !</description></item><item><title>React项目中同时添加css Modules与普通class</title><link>https://jo-hnny.github.io/p/react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0css-modules%E4%B8%8E%E6%99%AE%E9%80%9Aclass/</link><pubDate>Wed, 18 Sep 2019 21:16:58 +0800</pubDate><guid>https://jo-hnny.github.io/p/react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0css-modules%E4%B8%8E%E6%99%AE%E9%80%9Aclass/</guid><description>当我在 react 项目中为一个元素添加了 css modules 的样式，但是由于我要使用 iconfont，必须在元素上添加一个名为 iconfont 的 class 名称，搜来搜去也没找到什么优雅的实现，那就按照 class 的本质实现吧，class 本质就是一个字符串，多个 class 名由空格分割，故:
public render() { return ( &amp;lt;div className={`${styles.uploader}iconfont`}&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; className={styles[&amp;#39;file-input&amp;#39;]} /&amp;gt; &amp;amp;#xe7da; &amp;lt;/div&amp;gt; ) } 今天新发现一个库classnames可以很好的解决这个问题,使用如下：
import classNames from &amp;#34;classnames&amp;#34;; import React, { Component } from &amp;#34;react&amp;#34;; import styles from &amp;#34;./index.module.scss&amp;#34;; export default class extends Component { public uploadImage = (e: React.ChangeEvent&amp;lt;HTMLInputElement&amp;gt;) =&amp;gt; { console.log(e.target.files); }; public render() { return ( &amp;lt;div className={classNames(&amp;#34;iconfont&amp;#34;, styles.uploader)}&amp;gt; &amp;lt;input type=&amp;#34;file&amp;#34; accept=&amp;#34;image/png, image/jpeg&amp;#34; multiple={true} className={styles[&amp;#34;file-input&amp;#34;]} onChange={this.</description></item><item><title>(译)React+Redux+Typescript</title><link>https://jo-hnny.github.io/p/%E8%AF%91react-redux-typescript/</link><pubDate>Wed, 18 Sep 2019 21:14:23 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E8%AF%91react-redux-typescript/</guid><description>React + Redux + TypeScript - 成为更好的前端（教程） 我在开始构建 React 应用，但是我希望我的应用有一个好的构建方式，这是我在 Medium 上看到的一篇不错的教程，为了方便我理解，顺便学英语，翻译在此，英语版的可以点击查看原文
构建一个满意的 React 应用程序是比较困难的（主要是比较难找到一份 React 的最佳实践，这点 Angular 还是很优秀的，但是我喜欢 jsx）。当你掌握了 VirtualDOM 的概念以及框架是如何工作的时候，你会很快意识到单单使用 React 本身不足以构建比 TODO-LIST 更大的应用。这个时候你开始学习使用类似 Flux 这样的 store 架构，比如说应用最广泛的 Redux，很快你会沉没在 actions 和 reducers 中，并且你开始在保持数据分离上遇到更多的困难，这听起来你是不是很熟悉？
在本文中，我将介绍如何构建一个可扩展的应用程序，再看接下里的内容之前，我希望你已经明白 React 是如何工作的，并且对 Flux 或者 Redux 有一点了解。
本文是我由 2018 年 7 月 25 日 SwingDev 在 microConf 大会上的演讲整理而成的书面版本。更多的信息可以点击microconf.io.
为什么要使用 Store 如果你已经使用 React 编写过一个小的应用程序，那么你会发现好像少了些什么。
假设我们正在创建由两个主要组件构成的简单应用：包含所有电子邮件列表的侧边栏组件和显示当前所选电子邮件内容的内容组件。单击侧边栏的元素时，我们使用路由来更改页面的 URL 并将电子邮件的 ID 放在其中。但是我们需要在内容组件中获取到电子邮件的具体内容，即使侧边栏组件中已经存在该数据，我们依然无法在他的兄弟组件中获取到该数据。
你也许已经想到，我们可以把数据移动到父组件（包含了侧边栏组件和内容组件）来解决这个问题，但是这会产生许多潜在的问题和瓶颈。首先我们需要从父组件传递数据到子组件，并且将所有数据处理逻辑放到父组件中（例如删除邮件）。
使用 Flux 架构有助于解决这两个问题，它抽象了存储数据和操作数据（即 actions）的逻辑，并且提供了简单的方法将数据传递给需要它的组件（即 Redux 中的 connect 函数）。</description></item><item><title>Parcel简单试用</title><link>https://jo-hnny.github.io/p/parcel%E7%AE%80%E5%8D%95%E8%AF%95%E7%94%A8/</link><pubDate>Wed, 18 Sep 2019 21:11:32 +0800</pubDate><guid>https://jo-hnny.github.io/p/parcel%E7%AE%80%E5%8D%95%E8%AF%95%E7%94%A8/</guid><description>为什么要使用 有时候我想写个简单的 demo，但是我依然想要使用 ES6+的语法，还有 scss 以，node modules 包括一些其它的依赖，比如我要写 webgl 的 demo，我可能还需要引入一些 shader 文件，这个时候最先想到的肯定是 webpack 了，但是 webpack 的配置是真的麻烦，而我只是想写个 demo 而已，所以我把目光放到了 parcel 上，我 17 年就看到这货了，以为它能颠覆 webpack 呢，然并卵，我现在开始新项目还是得配置一大堆的 webpack 属性，但是在这种写个小 demo 的需求下，我想 parcel 应该能发挥它的价值。
开始 新建项目文件 mkdir webgl-demo 初始化项目 npm init -y 新建文件 在 index.html 文件中引入 index.js 文件，然后其他的依赖我们都会在 index.js 文件中引入 &amp;lt;!DOCTYPE html&amp;gt; &amp;lt;html lang=&amp;#34;en&amp;#34;&amp;gt; &amp;lt;head&amp;gt; &amp;lt;meta charset=&amp;#34;UTF-8&amp;#34; /&amp;gt; &amp;lt;meta name=&amp;#34;viewport&amp;#34; content=&amp;#34;width=device-width, initial-scale=1.0&amp;#34; /&amp;gt; &amp;lt;meta http-equiv=&amp;#34;X-UA-Compatible&amp;#34; content=&amp;#34;ie=edge&amp;#34; /&amp;gt; &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;canvas&amp;gt;&amp;lt;/canvas&amp;gt; &amp;lt;script src=&amp;#34;./index.js&amp;#34;&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/body&amp;gt; &amp;lt;/html&amp;gt; 在 index.</description></item><item><title>实现拉格朗日插值算法</title><link>https://jo-hnny.github.io/p/%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/</link><pubDate>Wed, 18 Sep 2019 21:10:50 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/</guid><description>实现拉格朗日插值算法 之前做图片曲线调节的时候使用到了拉格朗日插值算法，主要参考了维基百科，这里简单记录一下
什么是拉格朗日插值算法 如何通过给定的有限点得到拉格朗日插值函数 示例 维基百科上交代的算是比较明白了，然后我们要做的就是用代码去实现这个算法了，下面给出我的实现 const points = [ [4, 10], [5, 5.25], [6, 1], ]; const getLa = (points) =&amp;gt; { return (i) =&amp;gt; { function la(points, index = 0) { if (index === points.length) return 0; const [x, y] = points[index]; const up = points.reduce( (pre, [xn], upIndex) =&amp;gt; (upIndex === index ? pre : pre * (i - xn)), 1 ); const down = points.reduce( (pre, [xn], downIndex) =&amp;gt; (downIndex === index ?</description></item><item><title>冒泡排序与快排以及算法的时间复杂度</title><link>https://jo-hnny.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E6%8E%92%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</link><pubDate>Wed, 18 Sep 2019 21:10:17 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E6%8E%92%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</guid><description>简单的排序总是要会的嘛 推荐一个很好的 APP - 算法动画图解，以下解法都是参考该 APP 实现
冒泡排序 我不太好把 APP 的动画贴上来，大家可以自己搜索一下，但是主要的思想就是，从数组末位开始，依次和上一位两两比较，将较小的数交换到左边，那么第一轮下来之后，最左侧就是该数组最小的值，接下来重复之前的动作，将第二小的数字排在左侧倒数第二个，重复数组长度的次数之后即完成排序，下面是我的实现：
// 定义一个工具函数，用于交换数组中两个位置的值 function exchange(list, index1, index2) { [list[index1], list[index2]] = [list[index2], list[index1]]; } function bubbleSort(list) { let position = 0; const len = list.length; while (position &amp;lt; len) { for (let i = len - 1; i &amp;gt; position; i--) { if (list[i] &amp;lt; list[i - 1]) { exchange(list, i, i - 1); } } position++; } return list; } 快速排序 顾名思义，该排序的特点就是快，主要思想就是从原始数组中取一个基准值，然后比此值大的都放到右边，小的都放左边，然后取基准值左边的和右边的各为新数组，重复之前的步骤，也就是一种递归，最后直至左侧、右侧都只有一个元素或者 0 个元素，我的实现如下：</description></item><item><title>模拟实现call和apply以及bind</title><link>https://jo-hnny.github.io/p/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply%E4%BB%A5%E5%8F%8Abind/</link><pubDate>Wed, 18 Sep 2019 21:08:52 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply%E4%BB%A5%E5%8F%8Abind/</guid><description>模拟实现 call，apply 我就不写了，很相似 Function.prototype.callMe = function (that, ...args) { that[this.name] = this; that[this.name](...args); }; 模拟实现 bind Function.prototype.bindMe = function (that, ...args) { that[this.name] = this; return function () { that[this.name](...args); }; }; 总结 call 和 apply 都是为了改变函数在定义时原本的 this 指向，那么想想 this 的表现，始终指向调用自己的对象，我们要做的就是用 call 和 bind 提供的对象作为调用该函数的对象，即把该函数挂载为所提供对象的一个属性。</description></item><item><title>记一次webgl文本特效所踩的坑</title><link>https://jo-hnny.github.io/p/%E8%AE%B0%E4%B8%80%E6%AC%A1webgl%E6%96%87%E6%9C%AC%E7%89%B9%E6%95%88%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91/</link><pubDate>Wed, 18 Sep 2019 21:06:15 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E8%AE%B0%E4%B8%80%E6%AC%A1webgl%E6%96%87%E6%9C%AC%E7%89%B9%E6%95%88%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91/</guid><description>前情 项目做的是视频渲染，也就是视频渲染到 webgl 上，同时加上一些转场特效，文本效果，之前的文本效果我是用 DIV 标签加上 css3 的 animation 定位到 canvas 区域实现的，本着能用 webgl 实现就用 webgl 实现的初衷最后决定文本效果也用 webgl 实现，大致思路就是得到文本的纹理，然后用 shader 处理纹理实现动效,遇到的坑主要来自得到纹理时的字体效果。
使用 svg 得到文本纹理 由于 svg 前后端通用，能够保持一致，故初步决定使用 svg 实现文本纹理，步骤也就是拼接上颜色、字体、字号的属性得到一个 svg 字符串，然后将字符串转为一个 blob 地址，把这个地址给图片，以此得到纹理。
字体不生效 这么做了之后发现其余的文本大小、颜色都没问题，就是字体不生效，最后经过研究得出初步结论，我们使用的只是一个 svg 字符，并不能和项目中 css 声明的 font-face 关联起来，要想字体生效，必须把字体用 base64 的形式内联到 svg 中。
说干就干 不就是 base64 嘛，经过我修改 webpack loader 配置，字体文件成功内联到 svg 中，但是妈呀，这个 svg 真他么的大，几十 M 的字符，页面加载要转老半天，如果以后支持字体越来越多，那这个肯定不行的，得改一下，我觉得 ajax 动态请求字体为 blob，然后转 base64，果然这个方案好多了，页面加载很快，没有影响，于是接着开搞，结果到了从图片到纹理这一步的时候线程直接阻塞了，视频播放到这的时候，我的进度指针总会卡上一秒左右，非常影响体验，应该是这个图片体积太大了，这就无解了啊，又要字体生效，又要文件小，办不到啊。
换方案 没办法这个是行不通了，换方案吧，好像也没什么能换的了，只剩 canvas 了，那就上吧，生成一个 canvas 元素，画上文本，设置字体颜色，嗯，完美。
离完美还差一根头发丝的距离 最后还是发现了一点问题，那就是一开始切换字体的时候并没有生效，但是切上几次就又生效了，经过我多年前端经验猜测，浏览器本着为用户节约资源的美好想法，总是等你确实用到了这个字体的时候才去加载字体，也就是 canvas 上用到这个字体的时候才去加载字体，但是 canvas 是要马上生成纹理的，它可等不了你，于是就出现了一开始不生效，后面又生效的状况，那就提前使用字体吧，于是我在最外层的 html 上加了一些文本，分别指定了使用的字体，然后 display：none，结果居然还是不管用，妈的，浏览器想太多了，由于 display：none 你也看不到，所以浏览器还是没去加载资源，so，改成了绝对定位，top： -1000px，再一试，哈哈，好了。</description></item><item><title>基于mocha的nodejs单元测试</title><link>https://jo-hnny.github.io/p/%E5%9F%BA%E4%BA%8Emocha%E7%9A%84nodejs%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</link><pubDate>Wed, 18 Sep 2019 21:01:55 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%9F%BA%E4%BA%8Emocha%E7%9A%84nodejs%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</guid><description>为了学习这个，我写了一个例子，主要是一个基于 koa 的 restful 服务，然后是基于 mocha、supertest 的测试文件。
1、首先需要安装依赖 npm i supertest mocha chai --save-dev
2、npm script [ &amp;#34;scripts&amp;#34;: { &amp;#34;start&amp;#34;: &amp;#34;nodemon app.js&amp;#34;, &amp;#34;test&amp;#34;: &amp;#34;mocha&amp;#34; }, ] 3、目录结构 Mocha 默认运行 test 子目录里面的测试脚本。所以，一般都会把测试脚本放在 test 目录里面，然后执行 mocha 就不需要参数了
4、编写测试文件 在我的项目中有一个关于 user 的 rest 接口，user 的数据模型大致如下：
{ &amp;#34;name&amp;#34;: &amp;#34;wu&amp;#34;, &amp;#34;age&amp;#34;: 24, &amp;#34;likes&amp;#34;: [&amp;#34;movie&amp;#34;, &amp;#34;music&amp;#34;] } 4.1、引入需要的模块 const request = require(&amp;#34;supertest&amp;#34;)(&amp;#34;http://127.0.0.1:3000&amp;#34;); //初始化supertest const DB = require(&amp;#34;../db&amp;#34;); const USERS = new DB(&amp;#34;users&amp;#34;); const { expect } = require(&amp;#34;chai&amp;#34;); // 引入chai的expect断言 关于chai的使用可以去官网查看，比较简单</description></item><item><title>类的实现在es5与es6下的区别</title><link>https://jo-hnny.github.io/p/%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9C%A8es5%E4%B8%8Ees6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</link><pubDate>Wed, 18 Sep 2019 21:00:58 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9C%A8es5%E4%B8%8Ees6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/</guid><description>写完标题就后悔了，es6 的 class 只是语法糖，那么我要想知道 es5 的类的实现不是应该去看 es6 的源码吗？虽然这样，但是我的例子都已经写完了，我还是 po 上来吧，回头再看看 es6 是怎么实现的。
首先看看 ES6 的 class class A { constructor(x) { // 构造函数 this.x = x; // 为A的实例添加props属性 } test() { // 给A的实例添加方法 console.log(&amp;#34;test 实例方法&amp;#34;); } static test() { // 给A添加静态方法 console.log(&amp;#34;test 静态方法&amp;#34;); } } A.som = 123; // 给A添加静态属性，这个有点low,为什么不是static som = 123 // 实现继承 class B extends A { constructor(x, y) { super(x); this.y = y; } } const b = new B(1, 2); B.</description></item><item><title>面试记录</title><link>https://jo-hnny.github.io/p/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</link><pubDate>Wed, 18 Sep 2019 21:00:11 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/</guid><description>这里主要记录一些我没有回答上来的面试题
1、作用域链 今天接到了一个电话面试，感觉回答的很不好，我对 css 尤其不太擅长，BFC 这个没答上来，其实之前是有看到过的，但是由于自己对 css 的不重视，导致没有关注。
但是这篇文章要说的是作用域链，本来 js 算是我擅长的，这个没答上来实属不应该，就算我没关注这个概念，但是我应该知道它的正确情况的，就这么一个平时写代码觉得理所应当的东西，被问起来的时候我竟然答错了。
1.1、执行环境 执行环境定义了变量或函数有权访问的其他数据，每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的变量和函数都保存在这个对象中，全局执行环境是最外层的一个执行环境，每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入到一个环境栈中，当函数执行完毕，这个环境就会出栈并销毁，同时保存在其中的变量和函数也随之销毁，控制权交还给之前的执行环境。
1.2、作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的最前端，始终是当前执行的代码所在环境的变量对象，如果这个环境是函数，则将其活动对象（activation object）作为变量对象，，活动对象最开始只有一个变量，即 arguments 对象，作用域链中的下一个变量对象来自外部环境，再下一个则来自外部环境的外部环境，直到末端全局执行环境，这就形成了一个作用域链。
1.3、活动对象 1、当调用函数时，首先创建一个活动对象 2、为活动对象添加一个类似数组的 arguments 对象
3、将定义函数时所在的执行环境对应的作用域链复制到函数内部的[[scope]]属性上，把自己的活动对象推入作用域链的顶端
4、之后发生由 ECMA-262 中所谓’活动对象’完成的’变量实例化’(Variable Instatiation)的过程
(1)、此时将函数的形参创建为活动对象(变量对象)的属性，如果调用函数时传递的参数与形式参数一致，则将相应参数值赋给这些属性，否则，会给属性赋 undefined 值。 (2)、将函数内部声明的所有局部变量创建为活动对象(变量对象)的属性，其值都被'预解析'为undefined值，以上两步完成活动对象(变量对象)保存变量的过程。 (3)、对于定义的内部函数，用声明的函数名innerMethod，为活动对象(变量对象)创建同名属性，而定义的内部函数则被创建为函数对象并指定给该属性，完成活动对象(变量对象)保存函数的过程。 注：在这个过程中，除了实际参数和函数声明有值外，其它都被'预解析'为undefined值。 注：对于(1)、(2)、(3)步骤的顺序，因为变量声明比函数声明的优先级高，变量声明优先于函数声明被提升，如果两者同名同时存在，后被提升的函数声明会覆盖先被提升的变量声明**(引用来源作者(2)、(3)顺序反了)**。 注：对于(2)，函数被赋值为函数定义的字符串，并不会对函数体中的JS代码做特殊处理(如运算等)，只是将函数体JS代码的扫描结果(字符串)保存在活动对象(变量对象)的与此函数名对应的属性上，在函数执行时再做进一步处理。 2、数组去重 这是一个很经典的问题，当然最简单的回答就是使用 Set
const array = [1,2,3,2,4] [... new Set(array)] 很明显面试官不想再听到这个回答，然后我说了另一种方式
const array = [1, 2, 3, 2, 4]; array.reduce((targetAarr, item) =&amp;gt; { if (!targetAarr.includes(item)) targetAarr.push(item); return targetAarr; }, []); 然后面试官还想听到其他的方法，我就又说了一个对象键值对的方式
const array = [1, 2, 3, 2, 4]; const targetObject = {}; array.</description></item><item><title>学习RxJS</title><link>https://jo-hnny.github.io/p/%E5%AD%A6%E4%B9%A0rxjs/</link><pubDate>Wed, 18 Sep 2019 20:58:39 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%AD%A6%E4%B9%A0rxjs/</guid><description>一直想学习一下 RxJS，从一开始学习 android 的时候就听说过 RxJAVA，但是之前每次都看不下去，不太清楚这个是干什么的。今天下定决心要好好看一看。
1、Observable (可观察对象) RxJS 的核心概念就是观察者模式，也就是一个可观察对象会推送数据，一个观察者通过订阅接受这些数据，
创建一个可观察对象
var observable = Rx.Observable.create(function (observer) { observer.next(1); observer.next(2); observer.next(3); setTimeout(() =&amp;gt; { observer.next(4); observer.complete(); }, 1000); }); 每个 next()会向外抛出一个数据
2、Observer (观察者) 观察者通过订阅来拉取可观察对象的数据。
创建一个观察者
var observer = { next: (x) =&amp;gt; console.log(&amp;#34;Observer got a next value: &amp;#34; + x), error: (err) =&amp;gt; console.error(&amp;#34;Observer got an error: &amp;#34; + err), complete: () =&amp;gt; console.log(&amp;#34;Observer got a complete notification&amp;#34;), }; 观察者对象中你可以省略某一个函数，另外观察者也可以只是一个函数，那么它对应的就是 next 通知的处理方法。</description></item><item><title>Nodejs讲解区块链原理</title><link>https://jo-hnny.github.io/p/nodejs%E8%AE%B2%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/</link><pubDate>Wed, 18 Sep 2019 20:53:59 +0800</pubDate><guid>https://jo-hnny.github.io/p/nodejs%E8%AE%B2%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/</guid><description>前言 今天在YouTube上看到了一个系列视频，总共三集，讲解了怎么用 js 实现区块链，感觉浅显易懂，为了加深理解，凭着记忆和自己的理解再次自己实现一遍。
代码总共实现了三个类，
1、Block类用于生成区块实例，主要是存储信息，生成 hash；
2、BlockChain类用于将区块添加到链上，以及暴露添加交易记录、挖矿、获取用户账户资金、校验区块链安全性等方法。
3、Transaction类用于生成交易信息.
1、Block 类 区块链字面意思上理解就是区块构成的链，区块主要是存储着一些信息，其中不可或缺的有主体，即交易信息（当然本篇主要讲的是区块链货币，区块链也可能用于其他方面）， 时间戳，即区块生成时间，上一个区块的哈希值，本区块的哈希值（由上一个区块的哈希与本区块的数据共同生成，这样，当上一个区块被修改，那么本区块的哈希也需要被修改，才能与上一个区块的哈希对应起来，这样的话修改信息的人需要修改往后所有区块的信息）。
其中值得注意的是在区块链中有一个挖矿的概念，这个挖矿就是通过计算使得本区快的哈希值满足预设的要求，比如说比特币就是要求生成的区块的哈希值的前几位是n个0，这个n就代表了挖矿的难度系数，比特币会随着比特币的产出不断加大这个难度系数，使得挖矿变的越来越难
class Block { /** * * @param {Number} timestamp 时间戳 * @param {Array} transactions 交易信息 * @param {String} preHash 上一个区块的哈希值 * @param {Number} difficulty 难度系数 */ constructor(timestamp, transactions, preHash, difficulty) { Object.assign(this, { timestamp, transactions, preHash, hash: this.getHash(difficulty), }); } getHash(difficulty) { let hash = &amp;#34;&amp;#34;; let nonce = 0; do { const msg = `${this.timestamp}${JSON.stringify(this.data)}${nonce}`; hash = crypto.</description></item><item><title>__Proto__与prototype</title><link>https://jo-hnny.github.io/p/__proto__%E4%B8%8Eprototype/</link><pubDate>Wed, 18 Sep 2019 20:52:35 +0800</pubDate><guid>https://jo-hnny.github.io/p/__proto__%E4%B8%8Eprototype/</guid><description>之前也有看过资料，当时觉得明白了，但是时间一久就忘记了，一方面是平时工作中没有使用，另一方面是只是看，没有自己去思考，所以这次决定自己理一理。
首先看几个概念 1、__proto__原型对象 对象的__proto__指向创建它的构造函数的prototype,当你调用该对象的属性的时候，如果它自身没有这个属性，它会去__proto__上找这个属性
2、prototype 只有函数才有prototype属性，当你创建一个函数的时候，JS 会为这个函数添加prototype属性，值是一个有constructor属性的对象,(对象两个字很关键，这意味着这个对象也有__proto__属性,它指向创建它的构造函数即Object的prototype。)
接下来看看代码 function A() {} var a = new A(); console.log(A.__proto__ === Function.prototype); // true console.log(a.__proto__ === A.prototype); // true console.log(a.__proto__.__proto__ === Object.prototype); // true 然后同理我觉得下边的也应该成立
console.log(Object.prototype.__proto__ === Object.prototype); // false 但是事实很不幸，得到的是 false.
console.log(Object.prototype.__proto__); // null 打印一看是 null，然后再想想，其实 js 就是这样设计的而已，要不这个原型链不得没完没了了嘛,你想想有个对象找一个属性，它找到Object.prototype就应该到头了，要不它就会一直找下去，无尽循环。
然后我们看一个问题，就是Function与Object的问题 console.log(Object.__proto__ === Function.prototype); // true console.log(Function.__proto__ === Function.prototype); // true 可以看出Object是由Function构造出来的，而Function是由Function自己构造出来的，这个听起来好奇怪，自己构造自己。
constructor 下面再看看prototype.constructor
function A() {} var a = new A(); console.</description></item><item><title>初探react Native</title><link>https://jo-hnny.github.io/p/%E5%88%9D%E6%8E%A2react-native/</link><pubDate>Wed, 18 Sep 2019 20:51:20 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E5%88%9D%E6%8E%A2react-native/</guid><description>本文不介绍 React Native 的 API，API 可以参考官网或者 react native 中文网，主要是从环境搭建开始，利用豆瓣的开放 api 搭建一个豆瓣电影的应用。 一、环境搭建 环境搭建可以参考官网
必要的依赖
①、Python 2
②、Node
③、yarn
④、Android Studio
⑤、Expo
二、Hello World npm install -g create-react-native-app
选择一个文件夹作为你的项目地址
create-react-native-app douban_movie
cd douban_movie
npm start
等待命令行出现一个二维码，然后在手机上打开 expo 扫面这个二维码，就可以实时预览 app 效果了。
三、项目构思 目前在 豆瓣电影 API 中确认不用注册可以直接使用的接口有这些
按照这些 api 提供的信息大致确定页面结构为：
1、tab 导航页：包括搜索页面、top250、北美票房榜页面、正在上映页面、即将上映页面
2、详情页面：包括电影详情和演员详情
四、开工 1、项目目录结构： |------components | |------http | |------views | App.js | package.json 2、获取接口数据 在 react native 中进行 http 请求使用的 api 是fetch fetch是一种新的web HTTP请求api，现在已经内置在了大多数的浏览器中，在此之前web HTTP请求都是通过 XMLHttpRequest实现的</description></item><item><title>随笔</title><link>https://jo-hnny.github.io/p/%E9%9A%8F%E7%AC%94/</link><pubDate>Wed, 18 Sep 2019 20:50:02 +0800</pubDate><guid>https://jo-hnny.github.io/p/%E9%9A%8F%E7%AC%94/</guid><description>1、得到一个固定长度的非空的数组 比如我需要一个数组，元素是 1-10，首先我不想用直接手写一个数组，以前的实现方式:
new Array(10).fill(0).map((_, index) =&amp;gt; ++index); 为什么要加个 fill 呢，是因为 Array 构造函数返回的数组都是空位，就是什么都没有，连 undefined 都不是，map 方法不生效。 es6 扩展运算符的写法：
[...new Array(10)].map((_, index) =&amp;gt; ++index); 扩展运算符会将空位都变成 undefined。
2、es6 - Symbol 好像没什么好说的，最大的特点就是唯一性，但是也感觉到了一个问题，用它作为属性名的时候，要想取出来必须使用这个 Symbol 值，那么跨模块的时候，其它模块想取出这个值，还必须把这个 Symbol 值抛出去。
又看到了Symbol.for()，好像能解决问题，但是总感觉哪不对
3、getter 与 setter getter var obj = { log: [&amp;#34;example&amp;#34;, &amp;#34;test&amp;#34;], get latest() { if (this.log.length == 0) return undefined; return this.log[this.log.length - 1]; }, }; console.log(obj.latest); // &amp;#34;test&amp;#34;. var obj = { log: [&amp;#34;example&amp;#34;, &amp;#34;test&amp;#34;], latest() { if (this.</description></item><item><title>Web屏幕取词实现方式</title><link>https://jo-hnny.github.io/p/web%E5%B1%8F%E5%B9%95%E5%8F%96%E8%AF%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</link><pubDate>Wed, 18 Sep 2019 20:47:53 +0800</pubDate><guid>https://jo-hnny.github.io/p/web%E5%B1%8F%E5%B9%95%E5%8F%96%E8%AF%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/</guid><description>前些天项目需求要实现屏幕取词，通过我的调研使用 range api 实现了这个功能，后来我又分析了扇贝的开放 api，了解了扇贝的屏幕取词实现方式，在这里总结一下。
Range 方式 这是我在项目中实现屏幕取词的方式，其关键在于document.caretRangeFromPoint(float x, float y)方法，这个方法接收一个坐标，通过这个坐标生成一个 range 对象，通过这个 range 对象可以获取到当前点击的文本内容，以及当前点击的文本位置，我把这个实现方式封装成了一个包theword，已经上传到了 npm 仓库，下边通过代码分析一下：
export default (event, regexp = /[a-zA-Z&amp;#39;’]/) =&amp;gt; { // 监测一个字符是否是构成单词的字符 const isWord = (str) =&amp;gt; str &amp;amp;&amp;amp; regexp.test(str); const { clientX, clientY } = event; // 通过一个点生成range const range = document.caretRangeFromPoint(clientX, clientY); // 点击的dome节点的文本内容 const data = range.startContainer.data; // 点击的字符在文本中的位置 const point = range.startOffset; if (!isWord(data[point])) return; let j = point - 1; let k = point + 1; let wordArr = [data[point]]; // 从点击位置向前寻找符合构成单词条件的字符，直到遇到非构成单词的字符 while (isWord(data[j])) { wordArr.</description></item></channel></rss>