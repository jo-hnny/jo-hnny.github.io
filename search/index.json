[{"content":"为什么有这篇文章 最近我为开源项目 tkestack 的前端控制台部分添加了对 commit 的 lint，在添加过程中遇到了一些困难和疑惑，在此记录一下\nv4 配置方式 安装 husky npm i husky -D 添加配置 在 package.json 中添加如下配置\n//package.json \u0026#34;lint-staged\u0026#34;: { \u0026#34;./**/*.{ts,tsx,js,jsx}\u0026#34;: [ \u0026#34;eslint\u0026#34;, \u0026#34;prettier --write\u0026#34; ] }, \u0026#34;husky\u0026#34;: { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;lint-staged\u0026#34; } }, 或者添加.huskyrc 文件\n// .huskyrc { \u0026#34;hooks\u0026#34;: { \u0026#34;pre-commit\u0026#34;: \u0026#34;npm test\u0026#34; } } v6+ 配置方式 第一次使用，按照 husky doc 进行配置\n安装 husky npm i husky -D 开启 Git hooks npx husky install 执行到这里，我得到一个错误\nnpx husky install .git can\u0026#39;t be found (see https://git.io/Jc3F9) 可以推断出原因是这条命令需要在项目根目录执行。即.git所在的目录 tkestack 是一个前后端同在一个仓库的项目，目录结构如下\n. └── web └── console 我们现在在 console 目录，所以正确的方式应该是\ncd ../../ npx husky install ./web/console/.husky 添加自动执行husky install的钩子 如果其他用户进行开发，显然我们是不希望他需要先阅读 husky 的文档，然后手动执行npx husky install的，所以我们添加一个 npm scripts 的钩子\nnpm set-script prepare \u0026#34;husky install\u0026#34; 由于目录的原因，对应的调整为\nnpm set-script prepare \u0026#34;cd ../../ \u0026amp;\u0026amp; husky install ./web/console/.husky\u0026#34; 注意 ⚠️：npm set-script 只在 npm version 7.x 生效,如果你用的是 6.x 或者更低，还是手动在package.json中添加吧\n现在查看package.json 应该可以看到\n// package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;prepare\u0026#34;: \u0026#34;cd ../../ \u0026amp;\u0026amp; husky install ./web/console/.husky\u0026#34; } } 添加我们的 hook npx husky add .husky/pre-commit \u0026#34;lint-staged\u0026#34; 测试一下 修改一个文件使之不符合 eslint 规范，然后我们做一次提交\ngit add . git commit \u0026#39;test husky\u0026#39; 结果居然成功提交了，显然我们的 lint 没有生效\n我们检查一下现在我们的 console 目录有哪些变化，会发现多了一个.husky 目录，目录下有一个pre-commit文件,文件内容如下：\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; lint-staged 大致可以猜测到当 pre-commit 时，实际是执行了这个 shell 脚本，由于我们的 lint-staged 并不是全局安装，在这里并不能执行 所以我们在 package.json 中添加一个 script\n// package.json { \u0026#34;scripts\u0026#34;: { \u0026#34;prepare\u0026#34;: \u0026#34;cd ../../ \u0026amp;\u0026amp; husky install\u0026#34;, \u0026#34;pre-commit\u0026#34;: \u0026#34;lint-staged\u0026#34; } } 接着修改.husky/pre-commit文件\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; npm run pre-commit 再尝试一下修改一个文件并提交\n还是成功了，lint 依然没有生效，\n查看文档可知pre-commit这个 shell 实际执行目录是在.git所在目录，所以接着修改.husky/pre-commit文件\n#!/bin/sh . \u0026#34;$(dirname \u0026#34;$0\u0026#34;)/_/husky.sh\u0026#34; cd ./web/console npm run pre-commit 最后再次修改文件并 commit，终于可以看到命令行执行了lint-staged，lint 失败，commit 未成功\n为什么从 v4 到 v6 很显然，v6 的配置 相比 v4 复杂了很多,那么为什么 husky 官方要修改之前的配置方式呢？ 要了解这个问题之前我们先看一下 husky v4 的工作方式\nhusky@v4 是如何运行的 首先 husky 在安装时会在 .git/hooks/ 目录安装所有可能会使用到的 hooks\n比如当我们进行一次提交时，每个 git hook 检查我们有没有在 package.json 或者.huskyrc 中定义对应的钩子:\n$ git commit pre-commit (native) → husky/runner.js (node) → is a pre-commit defined in `.huskyrc.js`? → YES, run it prepare-commit-msg (native) → husky/runner.js (node) → is a prepare-commit-msg defined in `.huskyrc.js`? → NO, do nothing commit-msg (native) → husky/runner.js (node) → is a commit-msg defined in `.huskyrc.js`? → NO, do nothing post-commit (native) → husky/runner.js (node) → is a post-commit defined in `.huskyrc.js`? → NO, do nothing   优点： 用户可以在配置文件中添加、更新、删除 hook，husky 会自动判断执行\n  缺点： 不管我们有没有配置 hook，所有的 git hook 都会执行一遍，包括执行 node husky/runner.js\n  husky@v6 是如何运行的 2016 年，Git 2.9 引入了core.hooksPath，他使用户可以自定义 git hooks 的目录,在此之前，hooks 只能放在.git/hooks/目录下,然而.git 目录是不能提交的，但是现在配置core.hooksPath之后，比如 husky 使用husky install 配置 .husky/作为 git hooks 目录，我们可以提交.husky/目录作为项目的一部分。\n 优点：  避免了创建和运行所有 git hooks 现在 git hooks 和 husky 配置文件实际上是一个文件，方便管理   缺点：  配置复杂繁琐    参考 husky doc\nWhy husky has dropped conventional JS config\n","date":"2021-07-06T14:24:51+08:00","image":"https://jo-hnny.github.io/p/huskyv7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/cover_hu01741809d1f58ad23f9de5fc011deff8_4984873_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/huskyv7%E4%BD%BF%E7%94%A8%E6%8C%87%E5%8D%97/","title":"Husky@v7使用指南"},{"content":" 图摄于西湖\n 本文以 ubuntu18.0.4 为例\n安装 ZSH sudo apt-get install zsh\n设置 ZSH 为默认 shell chsh -s $(which zsh)\n安装ohmyzsh sh -c \u0026quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)\u0026quot;\n但是由于网络的问题，我总是遇到这个错误：\nFailed to connect to raw.github.com port 443: Connection refused\n所以我换了个方法，先把 ohmyzsh 的 GitHub 仓库克隆下来,然后再安装：\n git clone https://github.com/ohmyzsh/ohmyzsh.git sh -c ohmyzsh/tools/install.sh  zsh 插件和主题配置 安装spaceship主题  git clone https://github.com/denysdovhan/spaceship-prompt.git \u0026quot;$ZSH_CUSTOM/themes/spaceship-prompt\u0026quot; --depth=1 ln -s \u0026quot;$ZSH_CUSTOM/themes/spaceship-prompt/spaceship.zsh-theme\u0026quot; \u0026quot;$ZSH_CUSTOM/themes/spaceship.zsh-theme\u0026quot;  安装zsh-autosuggestions插件 这个插件主要作用是记录下历史命令，在你输入一部分时自动提示补全\ngit clone https://github.com/zsh-users/zsh-autosuggestions ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-autosuggestions\n安装zsh-syntax-highlighting插件 这个插件主要功能是高亮你输入的正确的命令\ngit clone https://github.com/zsh-users/zsh-syntax-highlighting.git ${ZSH_CUSTOM:-~/.oh-my-zsh/custom}/plugins/zsh-syntax-highlighting\n最后配置.zshrc 文件  vi ~/.zshrc ZSH_THEME=\u0026quot;spaceship\u0026quot; plugins=(git zsh-autosuggestions zsh-syntax-highlighting) source ~/.zshrc  最后记录一下 ssh 登录 ubuntu root 所需要的一些配置 默认 ubuntu root 账号无法 ssh 连接，一开始不知道，死活连不上\n设置 root 账户密码 sudo passwd\n按照提示输入并确认密码\n修改 ssh 配置  打开 ssh 配置 sudo vi /etc/ssh/sshd_config 修改 PermitRootLogin yes 重启 ssh sudo service ssh restart 重新 ssh 连接 root 用户  ","date":"2021-01-04T10:39:16+08:00","image":"https://jo-hnny.github.io/p/zsh%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/cover_hu9d339b934dffcf255507bb48006cd78d_7347600_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/zsh%E9%85%8D%E7%BD%AE%E6%8C%87%E5%8D%97/","title":"ZSH配置指南"},{"content":"又长了一岁 越来越没办法忽视自己的年龄，但是每个人的路注定是不一样的，也许我的注定坎坷一点，加油， better than better\n祝大家新年新气象  Happy New Year   Rabbit Girl   Cat Girl \n插图来自最近喜欢的日本画师 天凪える .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; }  🍼お知らせ🍼\n年賀状の再販することになりました💌\nすでに販売スタートしてます🐾\n今回はお名前とメッセージはなしで直筆サインのみですのでご注意ください！！\n12/30 22時までの販売なのでよろしくお願いしますにゃんฅ( ´ ^ ` ฅ)https://t.co/wbBHAB0ZRJ #booth_pm pic.twitter.com/9SZ7bMdy2l\n\u0026mdash; 天凪える🍼🐾お休み中 (@amanagiel) December 27, 2020 ","date":"2020-12-28T11:08:45+08:00","image":"https://jo-hnny.github.io/p/happy-birthday-with-new-year/cover_hu4d97dd12715d2145d15f97493ddd5f65_5555706_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/happy-birthday-with-new-year/","title":"Happy Birthday With New Year"},{"content":"又折腾了 之前下定决心不折腾的，就只是用 github pages 默认的主题，最简单的方式，但是从那之后很久都没有打开过博客了，好像兴趣丧失了，这次正好看到这个主题很喜欢，就又折=折腾一下，不过 actions 部署好了，后面写博客也就很简单啦！\n年终了 今年不出意料的过的很快，但是也发生了很多事情，从杭州撤了回来，其实心里感觉是自己认输了，躺平了，不挣扎了，但是想想对自己来说应该是最好的选择了，之前那样的状态，不知道能不能活到现在呢！\n新年期待   攒钱\n  变得更好，从内到外\n 矫正的事情去医院看看方案 近视的事情，尚未想好，不戴眼镜自然是绝佳的 脸上的疤也可以去咨询一下，最好皮肤状态稳定 心能静下来 多参加户外活到    把想写的开源项目写了\n 图片的 - 先写这个 视频的 - 慢慢来    工作上\n 学习一下 go 学习 k8s 相关    感情\n \u0026hellip;    过年要做的事情\n 给爸妈买套衣服吧，毕业也好几年了，还没给他们买过    ","date":"2020-12-23T17:01:19+08:00","image":"https://jo-hnny.github.io/p/%E5%8F%88%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E5%95%A6/cover_hue815052c239014777f9dec990de4542a_1567547_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/%E5%8F%88%E6%8A%98%E8%85%BE%E5%8D%9A%E5%AE%A2%E5%95%A6/","title":"又折腾博客啦"},{"content":"循环 function find2(data: number[], n) { let low = 0; let higth = data.length; let middleIndex = low + Math.floor((higth - low) / 2); let middleValue = data[middleIndex]; while (n !== middleValue) { if (higth \u0026lt;= low) { return -1; } if (n \u0026lt; middleValue) { higth = middleIndex; } else { low = middleIndex; } middleIndex = low + Math.floor((higth - low) / 2); middleValue = data[middleIndex]; } return middleIndex; } // test  const array = [...new Array(1000)].map((_, index) =\u0026gt; index); const n = 500; console.log(find2(array, n)); 递归 // 二分查找 - 递归法 function find2(data: number[], n: number, preIndex: number = 0) { const len = data.length; if (len \u0026lt;= 0) { return -1; } const middleIndex = Math.floor(len / 2); const middleValue = data[middleIndex]; if (n \u0026lt; middleValue) { return find2(data.slice(0, middleIndex), n, preIndex); } if (n === middleValue) { return preIndex + middleIndex; } if (n \u0026gt; middleValue) { return find2( data.slice(middleIndex + 1, len), n, preIndex + middleIndex + 1 ); } } // test  const array = [...new Array(1000)].map((_, index) =\u0026gt; index); const n = 500; console.log(find2(array, n)); ","date":"2020-12-23T11:55:21+08:00","image":"https://jo-hnny.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/cover_huc924efba91b0c18895da55f8ccb26750_913071_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","title":"二分查找"},{"content":"今天尝试在项目中完成切换主题的功能，目前已经实现，故做个记录  新建一个 scss 文件保存颜色配置，例如：  // themes.scss  $themes: ( light: ( main: #364f6b, second: #3fc1c9, third: #f5f5f5, fourth: #fc5185, ), dark: ( main: #e4f9f5, second: #30e3ca, third: #11999e, fourth: #40514e, ), ); 新建另一个 scss 文件，创建 mixin：  // themify.scss @import \u0026#34;./themes.scss\u0026#34;; @mixinthemify($themes: $themes) { @each $theme, $map in $themes { :global(.theme-#{$theme}) \u0026amp; { $theme-map: () !global; @each $key, $submap in $map { $value: map-get(map-get($themes, $theme), \u0026#34;#{$key}\u0026#34;); $theme-map: map-merge( $theme-map, ( $key: $value, ) ) !global; } @content; $theme-map: null !global; } } } @functionthemed($key) { @return map-get($theme-map, $key); } 使用：  @import \u0026#34;../../assets/styles/themify.scss\u0026#34;; .header { width: 100%; height: 60px; padding: 0 20px; display: flex; justify-content: flex-end; align-items: center; @includethemify { background-color: themed(\u0026#34;main\u0026#34;); color: themed(\u0026#34;third\u0026#34;); } } 最后：  import React, { useState } from \u0026#34;react\u0026#34;; import styles from \u0026#34;./app.module.scss\u0026#34;; import classNames from \u0026#34;classnames\u0026#34;; import { Header } from \u0026#34;./components/header\u0026#34;; enum Themes { Light = \u0026#34;light\u0026#34;, Dark = \u0026#34;dark\u0026#34;, } function App() { const [theme, setTheme] = useState\u0026lt;Themes\u0026gt;(Themes.Light); function toggleTheme() { setTheme(theme === Themes.Light ? Themes.Dark : Themes.Light); } return ( \u0026lt;div className={classNames(styles.app, `theme-${theme}`)}\u0026gt; \u0026lt;Header toogleTheme={toggleTheme} /\u0026gt; \u0026lt;/div\u0026gt; ); } export default App; ","date":"2020-12-23T11:41:47+08:00","image":"https://jo-hnny.github.io/p/%E5%9C%A8scss%E5%92%8Ccss_module%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/cover_hu9efe6025afacf0be349490fd897a8728_1800161_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/%E5%9C%A8scss%E5%92%8Ccss_module%E7%8E%AF%E5%A2%83%E4%B8%AD%E5%88%87%E6%8D%A2%E4%B8%BB%E9%A2%98/","title":"在scss和css_module环境中切换主题"},{"content":"当我在 react 项目中为一个元素添加了 css modules 的样式，但是由于我要使用 iconfont，必须在元素上添加一个名为 iconfont 的 class 名称，搜来搜去也没找到什么优雅的实现，那就按照 class 的本质实现吧，class 本质就是一个字符串，多个 class 名由空格分割，故:\npublic render() { return ( \u0026lt;div className={`${styles.uploader}iconfont`}\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; className={styles[\u0026#39;file-input\u0026#39;]} /\u0026gt; \u0026amp;#xe7da; \u0026lt;/div\u0026gt; ) } 今天新发现一个库classnames可以很好的解决这个问题,使用如下：\nimport classNames from \u0026#34;classnames\u0026#34;; import React, { Component } from \u0026#34;react\u0026#34;; import styles from \u0026#34;./index.module.scss\u0026#34;; export default class extends Component { public uploadImage = (e: React.ChangeEvent\u0026lt;HTMLInputElement\u0026gt;) =\u0026gt; { console.log(e.target.files); }; public render() { return ( \u0026lt;div className={classNames(\u0026#34;iconfont\u0026#34;, styles.uploader)}\u0026gt; \u0026lt;input type=\u0026#34;file\u0026#34; accept=\u0026#34;image/png, image/jpeg\u0026#34; multiple={true} className={styles[\u0026#34;file-input\u0026#34;]} onChange={this.uploadImage} /\u0026gt; \u0026amp;#xe81c; \u0026lt;/div\u0026gt; ); } } ","date":"2019-09-18T21:16:58+08:00","image":"https://jo-hnny.github.io/p/react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0css-modules%E4%B8%8E%E6%99%AE%E9%80%9Aclass/cover_huefcbb9b8b5b12eb8cf00ffdf2b15a7b8_2697992_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/react%E9%A1%B9%E7%9B%AE%E4%B8%AD%E5%90%8C%E6%97%B6%E6%B7%BB%E5%8A%A0css-modules%E4%B8%8E%E6%99%AE%E9%80%9Aclass/","title":"React项目中同时添加css Modules与普通class"},{"content":"React + Redux + TypeScript - 成为更好的前端（教程） 我在开始构建 React 应用，但是我希望我的应用有一个好的构建方式，这是我在 Medium 上看到的一篇不错的教程，为了方便我理解，顺便学英语，翻译在此，英语版的可以点击查看原文\n构建一个满意的 React 应用程序是比较困难的（主要是比较难找到一份 React 的最佳实践，这点 Angular 还是很优秀的，但是我喜欢 jsx）。当你掌握了 VirtualDOM 的概念以及框架是如何工作的时候，你会很快意识到单单使用 React 本身不足以构建比 TODO-LIST 更大的应用。这个时候你开始学习使用类似 Flux 这样的 store 架构，比如说应用最广泛的 Redux，很快你会沉没在 actions 和 reducers 中，并且你开始在保持数据分离上遇到更多的困难，这听起来你是不是很熟悉？\n在本文中，我将介绍如何构建一个可扩展的应用程序，再看接下里的内容之前，我希望你已经明白 React 是如何工作的，并且对 Flux 或者 Redux 有一点了解。\n本文是我由 2018 年 7 月 25 日 SwingDev 在 microConf 大会上的演讲整理而成的书面版本。更多的信息可以点击microconf.io.\n为什么要使用 Store 如果你已经使用 React 编写过一个小的应用程序，那么你会发现好像少了些什么。\n假设我们正在创建由两个主要组件构成的简单应用：包含所有电子邮件列表的侧边栏组件和显示当前所选电子邮件内容的内容组件。单击侧边栏的元素时，我们使用路由来更改页面的 URL 并将电子邮件的 ID 放在其中。但是我们需要在内容组件中获取到电子邮件的具体内容，即使侧边栏组件中已经存在该数据，我们依然无法在他的兄弟组件中获取到该数据。\n你也许已经想到，我们可以把数据移动到父组件（包含了侧边栏组件和内容组件）来解决这个问题，但是这会产生许多潜在的问题和瓶颈。首先我们需要从父组件传递数据到子组件，并且将所有数据处理逻辑放到父组件中（例如删除邮件）。\n使用 Flux 架构有助于解决这两个问题，它抽象了存储数据和操作数据（即 actions）的逻辑，并且提供了简单的方法将数据传递给需要它的组件（即 Redux 中的 connect 函数）。\nStore 架构 101（101 是什么梗,我还特意搜了一下，好像是初级的意思，大概就是 Store 架构初级教程吧） Store 架构是一个初级的概念，但是如果你以前从未听说，它可能听起来很奇怪，下图很好的描述了它：\n我们不再将所有数据保存到组件中，而是使用唯一的全局 Store 作为我们的事实上的数据来源。\n它定义了整个 UI，保存了所有动态数据-包括来自服务器的以及用户和应用的内部状态，我们基于这个 store 来构建我们的应用。\n当用户触发了一个操作 =》 比如在页面上点击一个按钮 =》 调用 Action（Action 是一个简单的对象，仅包含一个表明 action 类型的 type 属性和可选的补充数据）=》action 会发送到 reducer（一个具有单一作用的函数，它依据 action 和旧的 state 生成一个新的 state，比如用户点击按钮新创建了一封邮件，reducer 就会把新邮件添加到旧的邮件列表中，生成一个新的邮件列表，当然，reducer 返回的是一个完整的 state，邮件列表包含在其中）=》新的 store 传递给组件 =》组件相应的更新 UI\nTypeScript + React = ❤️ Angular 开发者默认使用 TypeScript 作为开发语言。React 应用仍然主要使用 javascript 开发，使用强类型语言可能会在一开始使得开发变得复杂，但是如果你按照规则使用，则会在后续的开发中给你带来极大的作用。我们在本文中构建 的应用程序使用 Typescript 进行开发，以表明在 Typescript 的帮助下重构 Redux store 是多么容易。\n将 TypeScript 与 React 一起使用可以从多方面获益。除了使用类型化语言的常见好处之外（您可以在此处阅读更多相关信息），在编写 React 项目时您可以轻松输入 Props 和 State，比如你使用一个组件时，IDE 会提示该组件所需要的所有 props，如果你忘记了添加组件需要的必须属性，Typescript 也会提醒你（确实会避免很多低级错误，往往这种低级 bug 最为致命，浪费极多的时间）。\n但是不仅如此，使用 Typescript 扩展 Redux 还有更多的好处，你的 store 键入就是其中之一，你无须点击跳转到 Reducer 来推测 store 的数据结构，此外当你键入 action 或者 action 生成器（工厂模式）时不用猜测它们接收什么类型的参数。\n让我们来写个示例：\nfunction searchAction(options) { return { type: ‘SEARCH’, ...options }; } 这是一个简单的 action 生成器，它接收 options 参数生成一个 type 为 SEARCH 的新 action，你能告诉我它到底要接收一个什么样的 options 吗？\n没有任何提示我们到底要传递什么参数给它，你可能会找遍整个项目来搞明白 options 对象到底是个什么，但是很有可能你找遍整个项目还是不知道到底要传什么参数！（深有体会，有时候甚至需要打开开发者工具查看接口到底返回了什么，然后再去推导数据结构）\n下面是重写为 Typescript 的版本，一眼看去可能会觉得有点复杂，但是附加的 interface 清除了所有混乱，使用此代码，你可以清晰的看到该函数需要唯一的一个包含有必要属性 text 和可选属性 tags（由数字构成的数组）的对象。\ninterface SearchActionOptions { text: string; tags?: number[]; } interface ISearchAction extends SearchActionOptions { type: string; } function searchAction(options: SearchActionOptions): ISearchAction { return { type: \u0026#34;SEARCH\u0026#34;, ...options, }; } 如果我们不正确的使用它，编辑器会给出相关提示！\n截图来自于 VisualStudio Code\n记事本 APP 本文会创建一个简单的记事本 APP，你可以在GitHub找到这个仓库，如果你想在已有代码的基础上编写，你可以从 master 分支检出代码。\n在仓库里你可以找到已配置的 React + TypeScript 项目，其中实现了所有组件并定义了所有基本 action，虽然缺少了 store。\n在这个应用中我们有三个 action：\n NOTES_FETCH 应用开始获取数据时调用 NOTES_FETCH_SUCCESS 应用获取数据成功时调用 NOTES_FETCH_ERROR 应用获取数据出错时调用  export interface IActionNotesFetch extends Action { type: \u0026#34;NOTES_FETCH\u0026#34;; } export interface IActionNotesFetchSuccess extends Action { type: \u0026#34;NOTES_FETCH_SUCCESS\u0026#34;; notes: NoteModel[]; } export interface IActionNotesFetchError extends Action { type: \u0026#34;NOTES_FETCH_ERROR\u0026#34;; errorMessage: string; } export type AppActions = | IActionNotesFetch | IActionNotesFetchSuccess | IActionNotesFetchError; 我们应该如何构造 store 以方便向用户展示数据？\n常见（不推荐）方法 最基本的 store 构造可能如下所示：\nexport interface NotesListState { state: string; // \u0026#39;INIT\u0026#39;, \u0026#39;LOADING\u0026#39; | \u0026#39;LOADED\u0026#39; | \u0026#39;ERROR\u0026#39;,  notes: NoteModel[]; errorMessage?: string; } 我们存储这个列表的当前状态：\n 初始状态 - 向服务器发送请求之前 加载中 - 等待服务器返回 加载完毕 - 已经获取数据到本地 错误 - 无法连接或者服务器错误  在此架构中对应的 reducer 可能如下：\nexport function notesListReducer( state: NotesListState, action: AppActions ): NotesListState { if (action.type === \u0026#34;NOTES_FETCH\u0026#34;) { return { ...state, state: \u0026#34;LOADING\u0026#34;, notes: [], }; } if (action.type === \u0026#34;NOTES_FETCH_SUCCESS\u0026#34;) { return { ...state, state: \u0026#34;LOADED\u0026#34;, notes: action.notes, }; } if (action.type === \u0026#34;NOTES_FETCH_ERROR\u0026#34;) { return { ...state, state: \u0026#34;ERROR\u0026#34;, notes: [], errorMessage: action.errorMessage, }; } return state; } 这是一个简单的函数，只有三个条件语句，分别对每个 action 做出反应。\n接下来唯一要做的就是把 store 与 React 组件连接起来，Redux 有一个函数 connect 可以很方便的帮我们实现这个功能，它接收两个回调函数，第一个将我们的全局 state 转换为组件的 props，第二个回调函数定义组件可用的 actions，我们把第一个函数更新为以下形式：\nconst mapStateToProps = (state: AppState, ownProps: HomeViewProps) =\u0026gt; { return { notes: state.list.notes, state: state.list.state, errorMessage: state.list.errorMessage, }; }; 你可以在 github 仓库中的sprint1-finish tag 下找到可用的版本。\n问与答 这个版本可以成功的加载和显示笔记（notes）。但是让我们思考一下，加入我们需要添加的下一个功能是-搜索。由于我们的 store 是一个全局单一数据源，所以当我们过滤掉某些 note 时，它就会从我们的 store 移除，这意味着在每次用户搜索时，我们都需要从服务器加载数据，以便向用户展示数据。\n但是如果我们想要展示另一个具有相同数据的列表，那么势必会有一些相同的条目同时出现在两个列表中，这会产生不必要的冗余，如果实际的内容和第二个列表的条目不同，又会产生歧义。\n不过，我们有一个叫做 store 规范化的方案可以将我们的 React/Redux 应用提升到一个新的水平。\nstore 规范化 要使用规范化，我们需要重新构思 store，在这里我们将它分为两类：\n 第一个是我们可以视为前端数据库的数据 store，它保存着可用实体的相关信息。该 store 必须独立于用户正在与之交互的实际视图。 第二个是我们的 UI store，这里包含有所有有关用户 UI 状态的信息，但是我的意思不是在 UI store 另外保存一份实体数据，而是保存条目的 id。  Redux 本身推荐的结构如下：\n{ entities: { notes: { byId: { 1: { id: 1, title: \u0026#39;First Note\u0026#39;, description: \u0026#39;Lorem Ipsum\u0026#39; }, 3: { id: 3, title: \u0026#39;Another Note\u0026#39;, description: \u0026#39;Dolor Sit Amet\u0026#39; } }, allIds: [1, 3] }, }, ui: { dashboardList: { state: \u0026#39;LOADED\u0026#39;, notes: [1, 3] } } } 我们主要的 store 分为两部分：entities 和 ui，ui 属性下的数据结构由开发者决定，但是最重要的是我们没有保存真正的笔记数据，而是保存笔记的 id。\n数据存储更加结构化。对于每个实体类型，我们保持对象包含两个属性：\n byId:将实体的 id 映射到其内容的对象 allIds 是我们当前商店中所有 ID 的数组  如果你想了解有关 store 规范化的更多信息，建议参考Using the Redux Store Like a Database by Nick Sweeting 和在 StackOverflow 上的讨论 Redux - Why normalize?\n改良版 让我们使用规范化重写一下，首先我们需要将 reducer 转换为 UI store，然后使用.map 函数将笔记映射到 ID 属性下：\nexport function notesListReducer(state: NotesListState, action: AppActions): NotesListState { if (action.type === \u0026#39;NOTES_FETCH\u0026#39;) { return { ...state, state: \u0026#39;LOADING\u0026#39;, notes: [], }; } if (action.type === \u0026#39;NOTES_FETCH_SUCCESS\u0026#39;) { return { ...state, state: \u0026#39;LOADED\u0026#39;, notes: action.notes*.map((n: NoteModel) =\u0026gt; n.id**)*, }; } if (action.type === \u0026#39;NOTES_FETCH_ERROR\u0026#39;) { return { ...state, state: \u0026#39;ERROR\u0026#39;, notes: [], errorMessage: action.errorMessage }; } return state; } 接下来我们需要为数据 store 定义 type，我们可以通过以下方式实现：\nexport type NotesDict = { [Key: number]: NoteModel; }; export type NotesDictState = { byId: NotesDict; allIds: number[]; }; 第一个 interface 是用 Typescript 的方式声明特定形式的对象，在这里我们定义 ById 为一个对象，以数字 id 作为键，NoteModel 作为属性。\n现在我们重新编写一个 reducer 更新 store：\nexport function notesDictReducer( state: NotesDictState, action: AppActions ): NotesDictState { if (action.type === \u0026#34;NOTES_FETCH_SUCCESS\u0026#34;) { return { byId: action.notes.reduce( (acc, note) =\u0026gt; ({ ...acc, [note.id]: note }), state ), allIds: action.notes.map((n) =\u0026gt; n.id), }; } return state; } 我们只对NOTES_FETCH_SUCCESS这个 action 做出反应，因为这是提供新数据的唯一操作，然后我们构建以 id 作为键的对象和包含所有 id 的数组。\n现在我们需要合并所有的 reducer 并且创建一个 main store 来保存这些数据：\nexport function mainReducer(state: AppState = defaultState(), action: Action) { return { entities: { notes: notesDictReducer(state.entities.notes, action), }, ui: { list: notesListReducer(state.ui.list, action), }, }; } 在实际项目中你可能会使用combineReducers来简化代码。\n接下来唯一要做的事就是更新我们的连接器（connector），现在我们的 UI 笔记列表只包含 id，因此我们需要将它映射到实际的笔记对象：\nconst mapStateToProps = (state: AppState, ownProps: HomeViewProps) =\u0026gt; { return { notes: state.ui.list.notes.map( (noteId) =\u0026gt; state.entities.notes.byId[noteId] ), state: state.ui.list.state, errorMessage: state.ui.list.errorMessage, }; }; 添加搜索 使用新架构添加搜索完全不是问题，首先，我们需要创建一个新的 action interface，看起来像下面这样：\nexport interface IActionSearchNotes { type: \u0026#34;NOTES_SEARCH\u0026#34;; options: { searchText: string; }; } 接下里我们需要更新 UI reducer：\nexport function notesListReducer( state: NotesListState, action: AppActions, notes: NotesDictState ): NotesListState { /* all other reducers */ if (action.type === \u0026#34;NOTES_SEARCH\u0026#34;) { return { ...state, notes: notes.allIds .map((id) =\u0026gt; notes.byId[id]) .filter(filterByText(action.options.searchText.toLowerCase())) .map((n) =\u0026gt; n.id), }; } return state; } 请注意，我们需要将数据 store 传递到 reducer 中，以便能够遍历所有元素并仅过滤出与搜索字符匹配的结果，你可以通过各种方式实现 filterByText 函数，下面是其中一种实现方式：\nfunction filterByText(text: string): (n: NoteModel) =\u0026gt; boolean { return (note: NoteModel): boolean =\u0026gt; { return ( note.title.toLowerCase().indexOf(text) \u0026gt; -1 || note.content.toLowerCase().indexOf(text) \u0026gt; -1 ); }; } 该函数检查了笔记的标题或者内容是否能够与搜索匹配。\n好了，就是这么多了，我们已经实现了搜索，请注意我们事实上并没有触及连接器（connector），因为我们的 store 已经规范化，所以无需更新视图。添加更多的搜索功能或者排序功能也不需要有太多的更改。如果我们需要添加刷新功能与后台保持同步，我们应用中的所有实例将自动更新。\n摘要 我希望本文能够让您基本了解 Redux store 规范化的工作原理以及如何使用它来改进项目。如果您想通过此示例进行更多操作，我建议您执行以下一项或所有练习：\n 删除元素的功能 添加标记功能 添加按标签搜索的选项  本文基于 2018 年 7 月 25 日在波兰华沙举行的 SwingDev microConf“State of the State in React”研讨会。如果您想了解有关该活动的更多信息，请访问www.microconf.io。\n","date":"2019-09-18T21:14:23+08:00","image":"https://jo-hnny.github.io/p/%E8%AF%91react-redux-typescript/cover_hu214c846e4a0e357a14266a12e8b1a4b9_1120274_120x120_fill_q75_box_smart1.jpg","permalink":"https://jo-hnny.github.io/p/%E8%AF%91react-redux-typescript/","title":"(译)React+Redux+Typescript"},{"content":"为什么要使用 有时候我想写个简单的 demo，但是我依然想要使用 ES6+的语法，还有 scss 以，node modules 包括一些其它的依赖，比如我要写 webgl 的 demo，我可能还需要引入一些 shader 文件，这个时候最先想到的肯定是 webpack 了，但是 webpack 的配置是真的麻烦，而我只是想写个 demo 而已，所以我把目光放到了 parcel 上，我 17 年就看到这货了，以为它能颠覆 webpack 呢，然并卵，我现在开始新项目还是得配置一大堆的 webpack 属性，但是在这种写个小 demo 的需求下，我想 parcel 应该能发挥它的价值。\n开始 新建项目文件 mkdir webgl-demo 初始化项目 npm init -y 新建文件 在 index.html 文件中引入 index.js 文件，然后其他的依赖我们都会在 index.js 文件中引入 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34; /\u0026gt; \u0026lt;meta name=\u0026#34;viewport\u0026#34; content=\u0026#34;width=device-width, initial-scale=1.0\u0026#34; /\u0026gt; \u0026lt;meta http-equiv=\u0026#34;X-UA-Compatible\u0026#34; content=\u0026#34;ie=edge\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;canvas\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;script src=\u0026#34;./index.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; 在 index.js 中编写代码，引入依赖,我这代码就不写了，引入一下依赖吧 import fragShader from \u0026#34;./index.frag\u0026#34;; import vertShader from \u0026#34;./index.vert\u0026#34;; import \u0026#34;./index.scss\u0026#34;; 安装 parcel,可以全局安装，也可以安装到项目，我这就安装到项目了,推荐安装到项目，这样不会别人拿去不知道怎么用 npm i parcel-bundler -D 启动项目，实际上我把它加到 npm script 里面了 { \u0026#34;name\u0026#34;: \u0026#34;webgl-demo\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index.js\u0026#34;, \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;parcel index.html\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34; }, \u0026#34;keywords\u0026#34;: [], \u0026#34;author\u0026#34;: \u0026#34;\u0026#34;, \u0026#34;license\u0026#34;: \u0026#34;ISC\u0026#34;, \u0026#34;dependencies\u0026#34;: { \u0026#34;parcel-bundler\u0026#34;: \u0026#34;^1.12.3\u0026#34; }, \u0026#34;devDependencies\u0026#34;: { \u0026#34;glslify-bundle\u0026#34;: \u0026#34;^5.1.1\u0026#34;, \u0026#34;glslify-deps\u0026#34;: \u0026#34;^1.3.1\u0026#34; } } 接着启动项目\nnpm start 它就这么跑起来了，我真的是有点惊讶，我以为起码要自己安装一下其他的 loader 什么的，但是完全不需要，它会自己根据文件后缀，自动安装 loader 什么的，反正你是真的什么配置文件都不用写。\n结束 parcel 是真的强大，我以后终于可以随心所欲的写 demo 了，用我自己最喜欢的方式。\n","date":"2019-09-18T21:11:32+08:00","image":"https://picsum.photos/seed/0d93939eee4441478b76522c689dfce3/4096/2160","permalink":"https://jo-hnny.github.io/p/parcel%E7%AE%80%E5%8D%95%E8%AF%95%E7%94%A8/","title":"Parcel简单试用"},{"content":"实现拉格朗日插值算法 之前做图片曲线调节的时候使用到了拉格朗日插值算法，主要参考了维基百科，这里简单记录一下\n什么是拉格朗日插值算法 如何通过给定的有限点得到拉格朗日插值函数 示例 维基百科上交代的算是比较明白了，然后我们要做的就是用代码去实现这个算法了，下面给出我的实现 const points = [ [4, 10], [5, 5.25], [6, 1], ]; const getLa = (points) =\u0026gt; { return (i) =\u0026gt; { function la(points, index = 0) { if (index === points.length) return 0; const [x, y] = points[index]; const up = points.reduce( (pre, [xn], upIndex) =\u0026gt; (upIndex === index ? pre : pre * (i - xn)), 1 ); const down = points.reduce( (pre, [xn], downIndex) =\u0026gt; (downIndex === index ? pre : pre * (x - xn)), 1 ); return y * (up / down) + la(points, index + 1); } return la(points); }; }; const laFn = getLa(points); console.log(laFn(18)); // -11 我写这个的时候感觉难点倒是不在算法上，而是如何把算法转换为我们在程序中可用的函数\n","date":"2019-09-18T21:10:50+08:00","image":"https://picsum.photos/seed/a06caa46404f48529f7fd8cba609add4/4096/2160","permalink":"https://jo-hnny.github.io/p/%E5%AE%9E%E7%8E%B0%E6%8B%89%E6%A0%BC%E6%9C%97%E6%97%A5%E6%8F%92%E5%80%BC%E7%AE%97%E6%B3%95/","title":"实现拉格朗日插值算法"},{"content":"简单的排序总是要会的嘛 推荐一个很好的 APP - 算法动画图解，以下解法都是参考该 APP 实现\n冒泡排序 我不太好把 APP 的动画贴上来，大家可以自己搜索一下，但是主要的思想就是，从数组末位开始，依次和上一位两两比较，将较小的数交换到左边，那么第一轮下来之后，最左侧就是该数组最小的值，接下来重复之前的动作，将第二小的数字排在左侧倒数第二个，重复数组长度的次数之后即完成排序，下面是我的实现：\n// 定义一个工具函数，用于交换数组中两个位置的值 function exchange(list, index1, index2) { [list[index1], list[index2]] = [list[index2], list[index1]]; } function bubbleSort(list) { let position = 0; const len = list.length; while (position \u0026lt; len) { for (let i = len - 1; i \u0026gt; position; i--) { if (list[i] \u0026lt; list[i - 1]) { exchange(list, i, i - 1); } } position++; } return list; } 快速排序 顾名思义，该排序的特点就是快，主要思想就是从原始数组中取一个基准值，然后比此值大的都放到右边，小的都放左边，然后取基准值左边的和右边的各为新数组，重复之前的步骤，也就是一种递归，最后直至左侧、右侧都只有一个元素或者 0 个元素，我的实现如下：\nfunction quickSort(list) { const len = list.length; if (len \u0026lt; 2) return list; const left = []; const right = []; const basic = list[0]; list .slice(1) .forEach((item) =\u0026gt; (item \u0026gt;= basic ? right.push(item) : left.push(item))); return quickSort(left).concat(basic, quickSort(right)); } 算法时间复杂度 算法有好有坏，那么我们怎么衡量算法的好怀呢？这里就引入了时间复杂度的概念，比如上边的冒泡排序的时间复杂度为 O(n^2),而快排的时间复杂度则为 O(n*Logn),那么这个复杂度到底是如何得来的,我在知乎上边找到一篇回答讲的很好\n","date":"2019-09-18T21:10:17+08:00","image":"https://picsum.photos/seed/2b71bb853ecf406b9f615b4d6f90b521/4096/2160","permalink":"https://jo-hnny.github.io/p/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%E4%B8%8E%E5%BF%AB%E6%8E%92%E4%BB%A5%E5%8F%8A%E7%AE%97%E6%B3%95%E7%9A%84%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/","title":"冒泡排序与快排以及算法的时间复杂度"},{"content":"模拟实现 call，apply 我就不写了，很相似 Function.prototype.callMe = function (that, ...args) { that[this.name] = this; that[this.name](...args); }; 模拟实现 bind Function.prototype.bindMe = function (that, ...args) { that[this.name] = this; return function () { that[this.name](...args); }; }; 总结 call 和 apply 都是为了改变函数在定义时原本的 this 指向，那么想想 this 的表现，始终指向调用自己的对象，我们要做的就是用 call 和 bind 提供的对象作为调用该函数的对象，即把该函数挂载为所提供对象的一个属性。\n","date":"2019-09-18T21:08:52+08:00","image":"https://picsum.photos/seed/42a9af59d3a34710adcf0d7b8bf521d9/4096/2160","permalink":"https://jo-hnny.github.io/p/%E6%A8%A1%E6%8B%9F%E5%AE%9E%E7%8E%B0call%E5%92%8Capply%E4%BB%A5%E5%8F%8Abind/","title":"模拟实现call和apply以及bind"},{"content":"前情 项目做的是视频渲染，也就是视频渲染到 webgl 上，同时加上一些转场特效，文本效果，之前的文本效果我是用 DIV 标签加上 css3 的 animation 定位到 canvas 区域实现的，本着能用 webgl 实现就用 webgl 实现的初衷最后决定文本效果也用 webgl 实现，大致思路就是得到文本的纹理，然后用 shader 处理纹理实现动效,遇到的坑主要来自得到纹理时的字体效果。\n使用 svg 得到文本纹理 由于 svg 前后端通用，能够保持一致，故初步决定使用 svg 实现文本纹理，步骤也就是拼接上颜色、字体、字号的属性得到一个 svg 字符串，然后将字符串转为一个 blob 地址，把这个地址给图片，以此得到纹理。\n字体不生效 这么做了之后发现其余的文本大小、颜色都没问题，就是字体不生效，最后经过研究得出初步结论，我们使用的只是一个 svg 字符，并不能和项目中 css 声明的 font-face 关联起来，要想字体生效，必须把字体用 base64 的形式内联到 svg 中。\n说干就干 不就是 base64 嘛，经过我修改 webpack loader 配置，字体文件成功内联到 svg 中，但是妈呀，这个 svg 真他么的大，几十 M 的字符，页面加载要转老半天，如果以后支持字体越来越多，那这个肯定不行的，得改一下，我觉得 ajax 动态请求字体为 blob，然后转 base64，果然这个方案好多了，页面加载很快，没有影响，于是接着开搞，结果到了从图片到纹理这一步的时候线程直接阻塞了，视频播放到这的时候，我的进度指针总会卡上一秒左右，非常影响体验，应该是这个图片体积太大了，这就无解了啊，又要字体生效，又要文件小，办不到啊。\n换方案 没办法这个是行不通了，换方案吧，好像也没什么能换的了，只剩 canvas 了，那就上吧，生成一个 canvas 元素，画上文本，设置字体颜色，嗯，完美。\n离完美还差一根头发丝的距离 最后还是发现了一点问题，那就是一开始切换字体的时候并没有生效，但是切上几次就又生效了，经过我多年前端经验猜测，浏览器本着为用户节约资源的美好想法，总是等你确实用到了这个字体的时候才去加载字体，也就是 canvas 上用到这个字体的时候才去加载字体，但是 canvas 是要马上生成纹理的，它可等不了你，于是就出现了一开始不生效，后面又生效的状况，那就提前使用字体吧，于是我在最外层的 html 上加了一些文本，分别指定了使用的字体，然后 display：none，结果居然还是不管用，妈的，浏览器想太多了，由于 display：none 你也看不到，所以浏览器还是没去加载资源，so，改成了绝对定位，top： -1000px，再一试，哈哈，好了。\n总结 svg 坑比较多，而且我对他并不熟悉，还是 canvas 比较可爱\n","date":"2019-09-18T21:06:15+08:00","image":"https://picsum.photos/seed/8b427e54cff84b0fbdfdce68b842a094/4096/2160","permalink":"https://jo-hnny.github.io/p/%E8%AE%B0%E4%B8%80%E6%AC%A1webgl%E6%96%87%E6%9C%AC%E7%89%B9%E6%95%88%E6%89%80%E8%B8%A9%E7%9A%84%E5%9D%91/","title":"记一次webgl文本特效所踩的坑"},{"content":"为了学习这个，我写了一个例子，主要是一个基于 koa 的 restful 服务，然后是基于 mocha、supertest 的测试文件。\n1、首先需要安装依赖 npm i supertest mocha chai --save-dev\n2、npm script [ \u0026#34;scripts\u0026#34;: { \u0026#34;start\u0026#34;: \u0026#34;nodemon app.js\u0026#34;, \u0026#34;test\u0026#34;: \u0026#34;mocha\u0026#34; }, ] 3、目录结构 Mocha 默认运行 test 子目录里面的测试脚本。所以，一般都会把测试脚本放在 test 目录里面，然后执行 mocha 就不需要参数了\n4、编写测试文件 在我的项目中有一个关于 user 的 rest 接口，user 的数据模型大致如下：\n{ \u0026#34;name\u0026#34;: \u0026#34;wu\u0026#34;, \u0026#34;age\u0026#34;: 24, \u0026#34;likes\u0026#34;: [\u0026#34;movie\u0026#34;, \u0026#34;music\u0026#34;] } 4.1、引入需要的模块 const request = require(\u0026#34;supertest\u0026#34;)(\u0026#34;http://127.0.0.1:3000\u0026#34;); //初始化supertest const DB = require(\u0026#34;../db\u0026#34;); const USERS = new DB(\u0026#34;users\u0026#34;); const { expect } = require(\u0026#34;chai\u0026#34;); // 引入chai的expect断言 关于chai的使用可以去官网查看，比较简单\n4.2、describe 对测试进行描述,可以进行嵌套\ndescribe(\u0026#39;users api\u0026#39;, () =\u0026gt; { describe(\u0026#39;post: 新增一个用户\u0026#39;, () =\u0026gt; { }) } 4.3、钩子 mocha提供了四个钩子函数before、 after、afterEach 和 beforeEach。\n其中before钩子会在本区块的所有测试用例之前执行，beforeEach钩子会在本区快的每个测试用例之前执行，after与afterEach同理。\n比如我想在所有测试用例开始之前清空数据库中 USERS 的数据。\ndescribe(\u0026#39;users api\u0026#39;, () =\u0026gt; { before(async () =\u0026gt; { this.user = { name: \u0026#39;walala\u0026#39;, age: 8, likes: [] } await USERS.clear() }) ) 在这个钩子中我使用了async函数，你在下边也会看到使用 done 方法通知这个异步回调完成的方式， Mocha 内置对 Promise 的支持，允许直接返回 Promise，等到它的状态改变，再执行断言，而不用显式调用 done 方法\n4.4、it it第一个参数是对预期结果的描述，第二个参数是一个 callback，是详细的测试行为。\ndescribe(\u0026#34;users api\u0026#34;, () =\u0026gt; { before(async () =\u0026gt; { this.user = { name: \u0026#34;walala\u0026#34;, age: 8, likes: [], }; await USERS.clear(); }); describe(\u0026#34;post: 新增一个用户\u0026#34;, () =\u0026gt; { it(\u0026#34;返回200状态码，以及一个包含新增用户id的对象\u0026#34;, (done) =\u0026gt; { request .post(\u0026#34;/user\u0026#34;) .send(this.user) .expect(200) .end((err, res) =\u0026gt; { if (err) done(err); expect(res.body).to.have.property(\u0026#34;id\u0026#34;).equal(0); this.id = res.body.id; done(); }); }); }); describe(\u0026#34;get: 获取用户\u0026#34;, () =\u0026gt; { it(\u0026#34;返回状态码200， 以及用户对象\u0026#34;, (done) =\u0026gt; { request .get(`/user/${this.id}`) .expect(200) .end((err, res) =\u0026gt; { if (err) done(err); expect(res.body).to.be.deep.equal(this.user); done(); }); }); }); describe(\u0026#34;put: 修改\u0026#34;, () =\u0026gt; { before((done) =\u0026gt; { this.user = { name: \u0026#34;walala\u0026#34;, age: 28, likes: [], }; done(); }); it(\u0026#34;返回状态码200\u0026#34;, (done) =\u0026gt; { request.put(`/user/${this.id}`).send(this.user).expect(200).end(done); }); }); describe(\u0026#34;getAll: 获取所有用户\u0026#34;, () =\u0026gt; { it(\u0026#34;返回状态码200，以及包含用户对象的数组\u0026#34;, (done) =\u0026gt; { request .get(`/user`) .expect(200) .end((err, res) =\u0026gt; { if (err) done(err); expect(res.body).to.be.deep.include(this.user); done(); }); }); }); describe(\u0026#34;delete: 删除用户\u0026#34;, () =\u0026gt; { it(\u0026#34;返回状态码200\u0026#34;, (done) =\u0026gt; { request.get(`/user`).expect(200).end(done); }); }); }); 5、运行测试 npm start\nnpm test\n测试就完成了\n","date":"2019-09-18T21:01:55+08:00","image":"https://picsum.photos/seed/ccbd0034a97a40f299bb27b18bf93999/4096/2160","permalink":"https://jo-hnny.github.io/p/%E5%9F%BA%E4%BA%8Emocha%E7%9A%84nodejs%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","title":"基于mocha的nodejs单元测试"},{"content":"写完标题就后悔了，es6 的 class 只是语法糖，那么我要想知道 es5 的类的实现不是应该去看 es6 的源码吗？虽然这样，但是我的例子都已经写完了，我还是 po 上来吧，回头再看看 es6 是怎么实现的。\n首先看看 ES6 的 class class A { constructor(x) { // 构造函数  this.x = x; // 为A的实例添加props属性  } test() { // 给A的实例添加方法  console.log(\u0026#34;test 实例方法\u0026#34;); } static test() { // 给A添加静态方法  console.log(\u0026#34;test 静态方法\u0026#34;); } } A.som = 123; // 给A添加静态属性，这个有点low,为什么不是static som = 123  // 实现继承 class B extends A { constructor(x, y) { super(x); this.y = y; } } const b = new B(1, 2); B.test(); // test 静态方法 b.test(); // test 实例方法 console.log(B.som); // 123 console.log(b.x); // 1 console.log(b.y); // 2 写起来很简单\nes5 的实现 function A(x) { // 构造方法  this.x = x; // 为A的实例添加props属性 } A.prototype.test = function () { // 给A的实例添加方法  console.log(\u0026#34;test 实例方法\u0026#34;); }; A.test = function () { // 给A添加静态方法  console.log(\u0026#34;test 静态方法\u0026#34;); }; A.som = 123; // 给A添加静态属性  // 实现继承 function B(x, y) { A.apply(this, [x, y]); // 执行A的构造函数  this.y = y; } // B.__proto__ = A // 继承A的静态方法,这样写eslint会报错，mdn说是会带来性能问题，但是我觉得好像不会，其它的资料都用的是对象遍历添加，感觉有点麻烦  // B.prototype.__proto__ = A.prototype // 继承A的实例方法，prototype也是一个对象，他也有__proto__  // 找到一个新方法，实质是一样的，但是eslint不报错，但是看了一下兼容性，safari不支持  Object.setPrototypeOf(B, A); Object.setPrototypeOf(B.prototype, A.prototype); const b = new B(1, 2); B.test(); // test 静态方法 b.test(); // test 实例方法 console.log(B.som); // 123 console.log(b.x); // 1 console.log(b.y); // 2 略显复杂\n","date":"2019-09-18T21:00:58+08:00","image":"https://picsum.photos/seed/064c5fca816c45068b6c3cd7fa82dcf2/4096/2160","permalink":"https://jo-hnny.github.io/p/%E7%B1%BB%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%9C%A8es5%E4%B8%8Ees6%E4%B8%8B%E7%9A%84%E5%8C%BA%E5%88%AB/","title":"类的实现在es5与es6下的区别"},{"content":"这里主要记录一些我没有回答上来的面试题\n1、作用域链 今天接到了一个电话面试，感觉回答的很不好，我对 css 尤其不太擅长，BFC 这个没答上来，其实之前是有看到过的，但是由于自己对 css 的不重视，导致没有关注。\n但是这篇文章要说的是作用域链，本来 js 算是我擅长的，这个没答上来实属不应该，就算我没关注这个概念，但是我应该知道它的正确情况的，就这么一个平时写代码觉得理所应当的东西，被问起来的时候我竟然答错了。\n1.1、执行环境 执行环境定义了变量或函数有权访问的其他数据，每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的变量和函数都保存在这个对象中，全局执行环境是最外层的一个执行环境，每个函数都有自己的执行环境，当执行流进入一个函数时，函数的环境就会被推入到一个环境栈中，当函数执行完毕，这个环境就会出栈并销毁，同时保存在其中的变量和函数也随之销毁，控制权交还给之前的执行环境。\n1.2、作用域链 当代码在一个环境中执行时，会创建变量对象的一个作用域链，作用域链的最前端，始终是当前执行的代码所在环境的变量对象，如果这个环境是函数，则将其活动对象（activation object）作为变量对象，，活动对象最开始只有一个变量，即 arguments 对象，作用域链中的下一个变量对象来自外部环境，再下一个则来自外部环境的外部环境，直到末端全局执行环境，这就形成了一个作用域链。\n1.3、活动对象 1、当调用函数时，首先创建一个活动对象 2、为活动对象添加一个类似数组的 arguments 对象\n3、将定义函数时所在的执行环境对应的作用域链复制到函数内部的[[scope]]属性上，把自己的活动对象推入作用域链的顶端\n4、之后发生由 ECMA-262 中所谓’活动对象’完成的’变量实例化’(Variable Instatiation)的过程\n(1)、此时将函数的形参创建为活动对象(变量对象)的属性，如果调用函数时传递的参数与形式参数一致，则将相应参数值赋给这些属性，否则，会给属性赋 undefined 值。 (2)、将函数内部声明的所有局部变量创建为活动对象(变量对象)的属性，其值都被'预解析'为undefined值，以上两步完成活动对象(变量对象)保存变量的过程。 (3)、对于定义的内部函数，用声明的函数名innerMethod，为活动对象(变量对象)创建同名属性，而定义的内部函数则被创建为函数对象并指定给该属性，完成活动对象(变量对象)保存函数的过程。 注：在这个过程中，除了实际参数和函数声明有值外，其它都被'预解析'为undefined值。 注：对于(1)、(2)、(3)步骤的顺序，因为变量声明比函数声明的优先级高，变量声明优先于函数声明被提升，如果两者同名同时存在，后被提升的函数声明会覆盖先被提升的变量声明**(引用来源作者(2)、(3)顺序反了)**。 注：对于(2)，函数被赋值为函数定义的字符串，并不会对函数体中的JS代码做特殊处理(如运算等)，只是将函数体JS代码的扫描结果(字符串)保存在活动对象(变量对象)的与此函数名对应的属性上，在函数执行时再做进一步处理。 2、数组去重 这是一个很经典的问题，当然最简单的回答就是使用 Set\nconst array = [1,2,3,2,4] [... new Set(array)] 很明显面试官不想再听到这个回答，然后我说了另一种方式\nconst array = [1, 2, 3, 2, 4]; array.reduce((targetAarr, item) =\u0026gt; { if (!targetAarr.includes(item)) targetAarr.push(item); return targetAarr; }, []); 然后面试官还想听到其他的方法，我就又说了一个对象键值对的方式\nconst array = [1, 2, 3, 2, 4]; const targetObject = {}; array.forEach((item) =\u0026gt; (targetObject[item] = item)); Object.keys(targetObject); 很明显这种方式有个问题，不能区分'1'和1 再问我，我说了可以先排序，再查看相邻项是否相同，代码实现大概是这个样子，这儿不得不说到 sort 方法传参的问题，我之前一直是有自定义 callback 来排序的，面试官问我如果不传参是什么情况，这个我还正没注意到原来可以不传参，当然我直觉是如果不传参，应该是从小到大排序，但是我不知道的东西当然不敢胡说，就直接回答了不知道，回来一看，不传参的话，元素按照转换为的字符串的各个字符的 Unicode 位点进行排序。\nconst array = [1, 2, 3, 2, 4]; const targetArr = array.sort(); targetArr.forEach((item, index, arr) =\u0026gt; { if (item === arr[index + 1]) arr.splice(index, 1); }); console.log(targetArr); 说到这了，我再记录一下数组和字符串常常弄混的几个方法，之前每次用到这几个方法都会打开 mdn 的文档，虽然我觉得这样没什么，但是万一被问到了呢，我感觉我回答的时候好像就有说混了的。\n1、Array.prototype.slice:方法返回一个从开始到结束（不包括结束）选择的数组的一部分浅拷贝到一个新数组对象。且原始数组不会被修改。\narr.slice(); // [0, end]  arr.slice(begin); // [begin, end]  arr.slice(begin, end); // [begin, end) 2、Aarray.prototype.splice:方法通过删除现有元素和/或添加新元素来更改一个数组的内容。\narray.splice(start) // 删除start - end array.splice(start, deleteCount) // 从start开始，包括start，删除deletecount个元素  array.splice(start, deleteCount, item1, item2, ...) // 删除元素，并且从start位置开始添加若干个元素 3、String.prototype.slice:方法提取一个字符串的一部分，并返回一新的字符串。不修改原字符串。\nstr.slice(beginSlice[, endSlice]) beginSlice\n从该索引（以 0 为基数）处开始提取原字符串中的字符。如果值为负数，会被当做 sourceLength + beginSlice 看待，这里的 sourceLength 是字符串的长度 (例如， 如果 beginSlice 是 -3 则看作是: sourceLength - 3)\nendSlice\n可选。在该索引（以 0 为基数）处结束提取字符串。如果省略该参数，slice 会一直提取到字符串末尾。如果该参数为负数，则被看作是 sourceLength + endSlice，这里的 sourceLength 就是字符串的长度(例如，如果 endSlice 是 -3，则是, sourceLength - 3)。\n这么看的话其实他和 Array 的用法基本一样\n4、String.prototype.split:方法使用指定的分隔符字符串将一个 String 对象分割成字符串数组，以将字符串分隔为子字符串，以确定每个拆分的位置。\n最后总结一下，Array和String都有slice方法，主要用来截取指定长度，Array有一个splice方法用来删除、添加元素，而String有一个slit方法用来把字符串分割成数组。\nupdate 2018.03.23 3、Promise 返回值的问题 被面试官问到 promise 连续点 then，第二个点 then 会返回什么，我很自信的说如果自己不指定返回值的话是 resolve 的值，事实上我错了：\nPromise.resolve(1) .then((rsp) =\u0026gt; console.log(rsp)) // 1  .then((rsp) =\u0026gt; console.log(rsp)); // undefined so then 函数 callback 接收的值应该是上一个 thencallback 返回的值。\n4、自己实现一个 co 下面是我一个简单的实现，主要就是要做到不断的递归调用：\nfunction co(gn) { gn = gn(); return new Promise((resolve, reject) =\u0026gt; { next(); function next(data) { const { done, value } = gn.next(data); if (done) return resolve(value); value.then((rsp) =\u0026gt; next(rsp)).catch((err) =\u0026gt; reject(err)); } }); } function* test() { const a = yield Promise.resolve(1); const b = yield Promise.resolve(2); return a + b; } co(test) .then((rsp) =\u0026gt; console.log(rsp)) // 3  .catch((err) =\u0026gt; console.log(err)); 建议这种问题最好能让上机写一下代码，让我干想和在纸上写实在是有点困难。\n5、prototype 的问题 现在才回想起来自己全说错了，当时还信誓旦旦，真是羞愧,都是自己的惯性思维，没有注意到这次是直接修改了 prototype 的指向,说到底还是对象引用的问题\nfunction A() {} function B() { this.hello = \u0026#34;hello\u0026#34;; } var a = new A(); A.prototype = new B(); var a1 = new A(); console.log(a.hello); // undefined console.log(a1.hello); // hello 现在一看，感觉这次面试又凉了。\n6、如何定义一个真正的常量 大家都知道 ES6 引入了 const 表示常量，但是大家也知道 const 并不能防止用户修改对象的属性，添加、删除属性，那么如何定义一个真正意义上的常量，这个并没有什么技术上的含量（当然我也试着从其他方面去实现，像是代理之类的，现在先不说），打开红宝书，翻到高级技巧-防篡改对象，在这里给大家介绍了几个对象的方法：\n6.1、不可扩展对象-即无法为对象添加属性； var a = { name: \u0026#34;johnny\u0026#34; }; Object.preventExtensions(a); a.age = 10; console.log(a.age); // undefined  a.name = \u0026#34;saber\u0026#34;; console.log(a.name); // saber  delete a.name; console.log(a.name); // undefined 6.2、密封的对象-不能添加、删除属性： var a = { name: \u0026#34;johnny\u0026#34; }; Object.seal(a); a.age = 10; console.log(a.age); // undefined  a.name = \u0026#34;saber\u0026#34;; console.log(a.name); // saber  delete a.name; console.log(a.name); // saber 6.3、冻结的对象-无法添加、删除、修改属性，真正的常量： var a = { name: \u0026#34;johnny\u0026#34; }; Object.freeze(a); a.age = 10; console.log(a.age); // undefined  a.name = \u0026#34;saber\u0026#34;; console.log(a.name); // johnny  delete a.name; console.log(a.name); // johnny 上面添加、删除、修改操作在非严格模式下为不生效，在严格模式下会报错，建议大家开启严格模式。\n","date":"2019-09-18T21:00:11+08:00","image":"https://picsum.photos/seed/dced38d5da1f47a591d1011c5276f6b4/4096/2160","permalink":"https://jo-hnny.github.io/p/%E9%9D%A2%E8%AF%95%E8%AE%B0%E5%BD%95/","title":"面试记录"},{"content":"一直想学习一下 RxJS，从一开始学习 android 的时候就听说过 RxJAVA，但是之前每次都看不下去，不太清楚这个是干什么的。今天下定决心要好好看一看。\n1、Observable (可观察对象) RxJS 的核心概念就是观察者模式，也就是一个可观察对象会推送数据，一个观察者通过订阅接受这些数据，\n创建一个可观察对象\nvar observable = Rx.Observable.create(function (observer) { observer.next(1); observer.next(2); observer.next(3); setTimeout(() =\u0026gt; { observer.next(4); observer.complete(); }, 1000); }); 每个 next()会向外抛出一个数据\n2、Observer (观察者) 观察者通过订阅来拉取可观察对象的数据。\n创建一个观察者\nvar observer = { next: (x) =\u0026gt; console.log(\u0026#34;Observer got a next value: \u0026#34; + x), error: (err) =\u0026gt; console.error(\u0026#34;Observer got an error: \u0026#34; + err), complete: () =\u0026gt; console.log(\u0026#34;Observer got a complete notification\u0026#34;), }; 观察者对象中你可以省略某一个函数，另外观察者也可以只是一个函数，那么它对应的就是 next 通知的处理方法。\n3、Subscription (订阅) 上边我们有了一个可观察对象和以一个可观察者，那么现在我们就需要使用订阅将他们联系起来\nvar subscription = observable.subscribe(observer); // Observer got a next value: 1 // Observer got a next value: 2 // Observer got a next value: 3 // Observer got a next value: 4 // Observer got a complete notification 当你订阅的时候，观察者就开始拉取数据了，同时会得到一个 Subscription 对象,它有一个unsubscribe()函数可以取消订阅，还有一个add()方法可以把另一个 Subscription 对象合并到自己身上，以及一个remove(otherSubscription) 方法，用来撤销一个已添加的子 Subscription。\n上边就是 RxJS 的基本概念了，下边会讲一些其它的扩展\n4、Subject (主体) subject 即是 Observable，又是 Observer\n作为 Observable（可观察对象） var subject = new Rx.Subject(); subject.subscribe({ next: (v) =\u0026gt; console.log(\u0026#34;observerA: \u0026#34; + v), }); subject.subscribe({ next: (v) =\u0026gt; console.log(\u0026#34;observerB: \u0026#34; + v), }); subject.next(1); subject.next(2); // 打印结果:  /* observerA: 1 observerB: 1 observerA: 2 observerB: 2 */ 作为 Observer（观察者） var subject = new Rx.Subject(); subject.subscribe({ next: (v) =\u0026gt; console.log(\u0026#34;observerA: \u0026#34; + v), }); subject.subscribe({ next: (v) =\u0026gt; console.log(\u0026#34;observerB: \u0026#34; + v), }); var observable = Rx.Observable.from([1, 2, 3]); observable.subscribe(subject); // 你可以提供一个 Subject 进行订阅  // 打印结果  /* observerA: 1 observerB: 1 observerA: 2 observerB: 2 observerA: 3 observerB: 3 */ subject 的多播 多播这个我有点不知道怎么说，普通的 observable 是单播的，意思就是两个订阅是互不影响、独立的，一个订阅完毕之后再进行下一个订阅，但是 subject 是多播的，下边通过代码看一下他们的区别：\n// 普通observable单播 const { Observable, Subject } = require(\u0026#34;rxjs\u0026#34;); const observable = Observable.create((observer) =\u0026gt; { observer.next(1); observer.next(2); }); observable.subscribe((k) =\u0026gt; console.log(\u0026#34;from observer a:\u0026#34;, k)); observable.subscribe((k) =\u0026gt; console.log(\u0026#34;from observer b:\u0026#34;, k)); // from observer a: 1 // from observer a: 2 // from observer b: 1 // from observer b: 2 可以通过打印结果看出来，两个订阅是独立的，先打印完了 a，再打印完了 b。\nconst { Observable, Subject } = require(\u0026#34;rxjs\u0026#34;); const subject = new Subject(); const observable = Observable.create((observer) =\u0026gt; { observer.next(1); observer.next(2); }); subject.subscribe((k) =\u0026gt; console.log(\u0026#34;from observer a:\u0026#34;, k)); subject.subscribe((k) =\u0026gt; console.log(\u0026#34;from observer b:\u0026#34;, k)); observable.subscribe(subject); // from observer a: 1 // from observer b: 1 // from observer a: 2 // from observer b: 2 两个订阅是同时执行的。\n另外 subject 还有几个变种，我回头再补充。\n这一次的先讲到这吧，rxjs 的东西好多，头痛，下次更新 observable 的几种创建方法以及常用的操作符\n5、今天补充 observable 的几种创建方法 来自一个或多个值 Rx.Observable.of(\u0026#34;foo\u0026#34;, \u0026#34;bar\u0026#34;); 来自数组 Rx.Observable.from([1, 2, 3]); 来自事件 Rx.Observable.fromEvent(document.querySelector(\u0026#34;button\u0026#34;), \u0026#34;click\u0026#34;); 来自 promise Rx.Observable.fromPromise(fetch(\u0026#34;/users\u0026#34;)); 来自回调函数 // fs.exists = (path, cb(exists)) const exists = Rx.Observable.bindCallback(fs.exists); exists(\u0026#34;file.txt\u0026#34;).subscribe((exists) =\u0026gt; console.log(\u0026#34;Does file exist?\u0026#34;, exists) ); 自己创建 一开始讲到得 observable 都是这种自己创建得。\nvar myObservable = new Rx.Subject(); myObservable.subscribe((value) =\u0026gt; console.log(value)); myObservable.next(\u0026#34;foo\u0026#34;); var myObservable = Rx.Observable.create((observer) =\u0026gt; { observer.next(\u0026#34;foo\u0026#34;); setTimeout(() =\u0026gt; observer.next(\u0026#34;bar\u0026#34;), 1000); }); myObservable.subscribe((value) =\u0026gt; console.log(value)); 6、操作符 操作符是 Observable 类型上的方法，比如 .map(...)、.filter(...)、.merge(...)，等等。当操作符被调用时，它们不会改变已经存在的 Observable 实例。相反，它们返回一个新的 Observable ，它的 subscription 逻辑基于第一个 Observable 。\n看着看着发现其实 RxJS 的操作符的概念很宽，并不止我一开始以为的map、filter这些东西，总的来说它把操作符分为了实例操作符和静态操作符，和 js 中的实例方法与静态方法的意思差不多。\n简单来说实例操作符就是Observable实例上的方法，比如map、filter，而静态操作符就是Observable上挂载的方法，比如各种创建 Observable 实例的方法create、of、from\n","date":"2019-09-18T20:58:39+08:00","image":"https://picsum.photos/seed/b950dc5fee90419792f927c90bc40a88/4096/2160","permalink":"https://jo-hnny.github.io/p/%E5%AD%A6%E4%B9%A0rxjs/","title":"学习RxJS"},{"content":"前言 今天在YouTube上看到了一个系列视频，总共三集，讲解了怎么用 js 实现区块链，感觉浅显易懂，为了加深理解，凭着记忆和自己的理解再次自己实现一遍。\n代码总共实现了三个类，\n1、Block类用于生成区块实例，主要是存储信息，生成 hash；\n2、BlockChain类用于将区块添加到链上，以及暴露添加交易记录、挖矿、获取用户账户资金、校验区块链安全性等方法。\n3、Transaction类用于生成交易信息.\n1、Block 类 区块链字面意思上理解就是区块构成的链，区块主要是存储着一些信息，其中不可或缺的有主体，即交易信息（当然本篇主要讲的是区块链货币，区块链也可能用于其他方面）， 时间戳，即区块生成时间，上一个区块的哈希值，本区块的哈希值（由上一个区块的哈希与本区块的数据共同生成，这样，当上一个区块被修改，那么本区块的哈希也需要被修改，才能与上一个区块的哈希对应起来，这样的话修改信息的人需要修改往后所有区块的信息）。\n其中值得注意的是在区块链中有一个挖矿的概念，这个挖矿就是通过计算使得本区快的哈希值满足预设的要求，比如说比特币就是要求生成的区块的哈希值的前几位是n个0，这个n就代表了挖矿的难度系数，比特币会随着比特币的产出不断加大这个难度系数，使得挖矿变的越来越难\nclass Block { /** * * @param {Number} timestamp 时间戳 * @param {Array} transactions 交易信息 * @param {String} preHash 上一个区块的哈希值 * @param {Number} difficulty 难度系数 */ constructor(timestamp, transactions, preHash, difficulty) { Object.assign(this, { timestamp, transactions, preHash, hash: this.getHash(difficulty), }); } getHash(difficulty) { let hash = \u0026#34;\u0026#34;; let nonce = 0; do { const msg = `${this.timestamp}${JSON.stringify(this.data)}${nonce}`; hash = crypto.createHash(\u0026#34;sha256\u0026#34;).update(msg).digest(\u0026#34;hex\u0026#34;); nonce++; } while (hash.substr(0, difficulty) !== Array(difficulty).fill(0).join(\u0026#34;\u0026#34;)); return hash; } } 2、BlockChain 类 BlockChain 类在生成实例的时候会把第一个元区块放入到链中，这个区块不存储任何有用的信息， 使用者可以向实例中添加交易信息，实例会把这些交易信息暂存起来，直到矿工开始挖矿，挖矿成功后所暂存的交易信息就被写入了新生成的区块中，同时给予矿工的奖励会暂存起来，直到下一个区块生成，矿工就算真的收到了奖励。\nclass BlockChain { constructor() { this.chain = [this.createGenesisBlock()]; this.pendingTransactions = []; // 暂存交易信息的地方  this.miningReward = 100; // 给与矿工的奖励  this.difficulty = 3; // 难度系数  } createGenesisBlock() { return new Block(Date.now(), [], 0, 1); } lastBlock() { return this.chain[this.chain.length - 1]; } mine(miningRewardAddress) { const preHash = this.lastBlock().hash; const block = new Block( Date.now(), this.pendingTransactions, preHash, this.difficulty ); this.chain.push(block); this.pendingTransactions = [ new Transaction(null, miningRewardAddress, this.miningReward), ]; } createTransactions(transaction) { if (!this.isChainValid) return false; this.pendingTransactions.push(transaction); } isChainValid() { // 校验区块链是否未被修改  const len = this.chain.length; for (let i = 1; i \u0026lt; len; i++) { const curBlock = this.chain[i]; const preBlock = this.chain[i - 1]; if (curBlock.hash !== curBlock.getHash()) return false; if (curBlock.preHash !== preBlock.hash) return false; } return true; } getBalanceOfAddress(address) { // 获得某个账户的余额  let balance = 0; this.chain.forEach(({ transactions }) =\u0026gt; { transactions.forEach(({ fromAddress, toAddress, amount }) =\u0026gt; { if (fromAddress === address) balance -= amount; if (toAddress === address) balance += amount; }); }); return balance; } } 3、Transaction 类 Transaction 类没什么好说的，就是生成交易信息。\nclass Transaction { constructor(fromAddress, toAddress, amount) { Object.assign(this, { fromAddress, toAddress, amount, }); } } 后语 前言还是要搭一下后语的，上面只是用代码来讲了一下区块链的原理，真正的区块链细节要更加复杂，也还有其它的东西，比如说很重要的 p2p，对 p2p 还是很有兴趣的，后面有时间了再学习一下。\n另外，我还是很看好区块链的，它的作用远不止被用来圈钱割韭菜，我也买过 EOS，当然是亏了，但是我还是很看好它作为区块链平台的出发点。\n添一个所有代码（代码不多就不新建仓库了） const crypto = require(\u0026#34;crypto\u0026#34;); class Block { /** * * @param {Number} timestamp 时间戳 * @param {Array} transactions 交易信息 * @param {String} preHash 上一个区块的哈希值 * @param {Number} difficulty 难度系数 */ constructor(timestamp, transactions, preHash, difficulty) { Object.assign(this, { timestamp, transactions, preHash, hash: this.getHash(difficulty), }); } getHash(difficulty) { // 计算哈希直到满足要求  let hash = \u0026#34;\u0026#34;; let nonce = 0; do { const msg = `${this.timestamp}${JSON.stringify(this.data)}${nonce}`; hash = crypto.createHash(\u0026#34;sha256\u0026#34;).update(msg).digest(\u0026#34;hex\u0026#34;); nonce++; } while (hash.substr(0, difficulty) !== Array(difficulty).fill(0).join(\u0026#34;\u0026#34;)); return hash; } } class BlockChain { constructor() { this.chain = [this.createGenesisBlock()]; this.pendingTransactions = []; // 暂存交易信息的地方  this.miningReward = 100; // 给与矿工的奖励  this.difficulty = 3; // 难度系数  } createGenesisBlock() { return new Block(Date.now(), [], 0, 1); } lastBlock() { return this.chain[this.chain.length - 1]; } mine(miningRewardAddress) { const preHash = this.lastBlock().hash; const block = new Block( Date.now(), this.pendingTransactions, preHash, this.difficulty ); this.chain.push(block); this.pendingTransactions = [ new Transaction(null, miningRewardAddress, this.miningReward), ]; } createTransactions(transaction) { if (!this.isChainValid) return false; this.pendingTransactions.push(transaction); } isChainValid() { // 校验区块链是否未被修改  const len = this.chain.length; for (let i = 1; i \u0026lt; len; i++) { const curBlock = this.chain[i]; const preBlock = this.chain[i - 1]; if (curBlock.hash !== curBlock.getHash()) return false; if (curBlock.preHash !== preBlock.hash) return false; } return true; } getBalanceOfAddress(address) { // 获得某个账户的余额  let balance = 0; this.chain.forEach(({ transactions }) =\u0026gt; { transactions.forEach(({ fromAddress, toAddress, amount }) =\u0026gt; { if (fromAddress === address) balance -= amount; if (toAddress === address) balance += amount; }); }); return balance; } } class Transaction { constructor(fromAddress, toAddress, amount) { Object.assign(this, { fromAddress, toAddress, amount, }); } } const myChain = new BlockChain(); const tran1 = new Transaction(\u0026#34;addr1\u0026#34;, \u0026#34;addr2\u0026#34;, 10); myChain.createTransactions(tran1); const tran2 = new Transaction(\u0026#34;addr1\u0026#34;, \u0026#34;addr2\u0026#34;, 1); myChain.createTransactions(tran2); myChain.mine(\u0026#34;myAddr\u0026#34;); myChain.mine(\u0026#34;myAddr\u0026#34;); console.log(myChain.getBalanceOfAddress(\u0026#34;myAddr\u0026#34;)); ","date":"2019-09-18T20:53:59+08:00","image":"https://picsum.photos/seed/c6a1438cfc9d4682b65330ff7573994d/4096/2160","permalink":"https://jo-hnny.github.io/p/nodejs%E8%AE%B2%E8%A7%A3%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86/","title":"Nodejs讲解区块链原理"},{"content":"之前也有看过资料，当时觉得明白了，但是时间一久就忘记了，一方面是平时工作中没有使用，另一方面是只是看，没有自己去思考，所以这次决定自己理一理。\n首先看几个概念 1、__proto__原型对象 对象的__proto__指向创建它的构造函数的prototype,当你调用该对象的属性的时候，如果它自身没有这个属性，它会去__proto__上找这个属性\n2、prototype 只有函数才有prototype属性，当你创建一个函数的时候，JS 会为这个函数添加prototype属性，值是一个有constructor属性的对象,(对象两个字很关键，这意味着这个对象也有__proto__属性,它指向创建它的构造函数即Object的prototype。)\n接下来看看代码 function A() {} var a = new A(); console.log(A.__proto__ === Function.prototype); // true  console.log(a.__proto__ === A.prototype); // true  console.log(a.__proto__.__proto__ === Object.prototype); // true 然后同理我觉得下边的也应该成立\nconsole.log(Object.prototype.__proto__ === Object.prototype); // false 但是事实很不幸，得到的是 false.\nconsole.log(Object.prototype.__proto__); // null 打印一看是 null，然后再想想，其实 js 就是这样设计的而已，要不这个原型链不得没完没了了嘛,你想想有个对象找一个属性，它找到Object.prototype就应该到头了，要不它就会一直找下去，无尽循环。\n然后我们看一个问题，就是Function与Object的问题 console.log(Object.__proto__ === Function.prototype); // true  console.log(Function.__proto__ === Function.prototype); // true 可以看出Object是由Function构造出来的，而Function是由Function自己构造出来的，这个听起来好奇怪，自己构造自己。\nconstructor 下面再看看prototype.constructor\nfunction A() {} var a = new A(); console.log(A.prototype.constructor === A); // true 函数的prototype.constructor指向了自己，除此之外，我目前还没发现这个有什么用。\nfunction A() {} var a = new A(); console.log(A.prototype.constructor === A); // true  console.log(a.constructor === A); // true 找到一个说法\nconstructor属性不影响任何JavaScript的内部属性。instanceof检测对象的原型链，通常你是无法修改的（不过某些引擎通过私有的__proto__属性暴露出来）。constructor其实没有什么用处，只是JavaScript语言设计的历史遗留物。由于constructor属性是可以变更的，所以未必真的指向对象的构造函数，只是一个提示。不过，从编程习惯上，我们应该尽量让对象的constructor指向其构造函数，以维持这个惯例。 作者：贺师俊 链接：https://www.zhihu.com/question/19951896/answer/13457869 来源：知乎 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 ","date":"2019-09-18T20:52:35+08:00","image":"https://picsum.photos/seed/7a25d1e14d8d44d08048f21ffe09c5fe/4096/2160","permalink":"https://jo-hnny.github.io/p/__proto__%E4%B8%8Eprototype/","title":"__Proto__与prototype"},{"content":"本文不介绍 React Native 的 API，API 可以参考官网或者 react native 中文网，主要是从环境搭建开始，利用豆瓣的开放 api 搭建一个豆瓣电影的应用。 一、环境搭建 环境搭建可以参考官网\n必要的依赖\n①、Python 2\n②、Node\n③、yarn\n④、Android Studio\n⑤、Expo\n二、Hello World npm install -g create-react-native-app\n选择一个文件夹作为你的项目地址\ncreate-react-native-app douban_movie\ncd douban_movie\nnpm start\n等待命令行出现一个二维码，然后在手机上打开 expo 扫面这个二维码，就可以实时预览 app 效果了。\n三、项目构思 目前在 豆瓣电影 API 中确认不用注册可以直接使用的接口有这些\n按照这些 api 提供的信息大致确定页面结构为：\n1、tab 导航页：包括搜索页面、top250、北美票房榜页面、正在上映页面、即将上映页面\n2、详情页面：包括电影详情和演员详情\n四、开工 1、项目目录结构： |------components | |------http | |------views | App.js | package.json 2、获取接口数据 在 react native 中进行 http 请求使用的 api 是fetch fetch是一种新的web HTTP请求api，现在已经内置在了大多数的浏览器中，在此之前web HTTP请求都是通过 XMLHttpRequest实现的\n请注意，fetch 规范与 jQuery.ajax() 主要有两种方式的不同，牢记： 当接收到一个代表错误的 HTTP 状态码时，从 fetch()返回的 Promise 不会被标记为 reject， 即使该 HTTP 响应的状态码是 404 或 500。相反，它会将 Promise 状态标记为 resolve （但是会将 resolve 的返回值的 ok 属性设置为 false ）， 仅当网络故障时或请求被阻止时，才会标记为 reject。 默认情况下, fetch 不会从服务端发送或接收任何 cookies, 如果站点依赖于用户 session，则会导致未经认证的请求（要发送 cookies，必须设置 credentials 选项）.\n各浏览器对 fetch 的支持情况： /http/fetchApi.js export default fetchApi = (url) =\u0026gt; { return fetch(url).then((rsp) =\u0026gt; { if (rsp.ok) return rsp.json(); return Promise.reject(rsp.json()); }); }; /http/api.js import fetchApi from \u0026#34;./fetchApi\u0026#34;; const baseUrl = \u0026#34;https://api.douban.com/v2/movie/\u0026#34;; exports.movieInfo = (id) =\u0026gt; fetchApi(`${baseUrl}subject/${id}`); exports.actorInfo = (id) =\u0026gt; fetchApi(`${baseUrl}celebrity/${id}`); exports.search = (q, start = 0, count = 10) =\u0026gt; fetchApi(`${baseUrl}search?q=${q}\u0026amp;start=${start}\u0026amp;count=${count}`); exports.top250 = (start = 0, count = 10) =\u0026gt; fetchApi(`${baseUrl}top250?start=${start}\u0026amp;count=${count}`); exports.usBox = () =\u0026gt; fetchApi(`${baseUrl}us_box`); exports.showing = () =\u0026gt; fetchApi(`${baseUrl}in_theaters`); exports.comingSoon = (start = 0, count = 10) =\u0026gt; fetchApi(`${baseUrl}coming_soon?start=${start}\u0026amp;count=${count}`); 3、基础组件 /components 首先需要一个卡片组件来展示最基本的电影信息\u0026mdash;电影名称、海报、评分 /components/MovieCard.js 这里用到了一个组件库react-native-elements\nimport React from \u0026#34;react\u0026#34;; import { StyleSheet, Text, Image } from \u0026#34;react-native\u0026#34;; import { Card, Rating } from \u0026#34;react-native-elements\u0026#34;; export default class MovieCard extends React.Component { constructor(props) { super(props); } render() { return ( \u0026lt;Card title={this.props.title} image={{ uri: this.props.img }} containerStyle={styles.card} \u0026gt; \u0026lt;Rating type=\u0026#34;star\u0026#34; fractions={1} startingValue={this.props.rating} readonly imageSize={25} /\u0026gt; \u0026lt;/Card\u0026gt; ); } } const styles = StyleSheet.create({ card: { width: 150, height: 240, justifyContent: \u0026#34;space-around\u0026#34;, alignItems: \u0026#34;center\u0026#34;, }, }); 卡片列表组件 /components/ListPage.js import React from \u0026#34;react\u0026#34;; import { FlatList, TouchableHighlight, View, StyleSheet } from \u0026#34;react-native\u0026#34;; import MovieCard from \u0026#34;./MovieCard\u0026#34;; export default class ListPage extends React.Component { constructor(props) { super(props); } render() { const { navigate } = this.props.navigation; if (!this.props.movies.length) return \u0026lt;View\u0026gt;\u0026lt;/View\u0026gt;; return ( \u0026lt;FlatList data={this.props.movies} renderItem={({ item }) =\u0026gt; ( \u0026lt;TouchableHighlight onPress={() =\u0026gt; navigate(\u0026#34;MovieInfo\u0026#34;, { id: item.id })} \u0026gt; \u0026lt;View\u0026gt; \u0026lt;MovieCard img={item.images.small} rating={item.rating.average} title={item.title} /\u0026gt; \u0026lt;/View\u0026gt; \u0026lt;/TouchableHighlight\u0026gt; )} keyExtractor={(item) =\u0026gt; item.id} numColumns={2} onEndReachedThreshold={0.5} onEndReached={this.props.loadData} /\u0026gt; ); } } 4、页面 /views /views/Top250 /views/UsBox.js /views/Showing.js /views/ComingSoon.js 这几个页面的逻辑是相似的，只是数据不一样而已,就只看一下 Top250.js 的代码 import React from \u0026#34;react\u0026#34;; import { top250 } from \u0026#34;../http/api\u0026#34;; import ListPage from \u0026#34;../components/ListPage\u0026#34;; export default class Top250 extends React.Component { constructor() { super(); this.state = { movies: [], }; this.getTop250(); } static navigationOptions = { tabBarLabel: \u0026#34;Top 250\u0026#34;, }; getTop250 = () =\u0026gt; { top250(this.state.movies.length) .then((rsp) =\u0026gt; { this.setState((preSate) =\u0026gt; ({ movies: preSate.movies.concat(rsp.subjects), })); }) .catch((err) =\u0026gt; { console.log(\u0026#34;getTop250 error\u0026#34;, err); }); }; render() { return ( \u0026lt;ListPage movies={this.state.movies} loadData={this.getTop250} navigation={this.props.navigation} /\u0026gt; ); } } 搜索页面 /views/Home.js import React from \u0026#34;react\u0026#34;; import { StyleSheet, View } from \u0026#34;react-native\u0026#34;; import { SearchBar } from \u0026#34;react-native-elements\u0026#34;; import { search } from \u0026#34;../http/api\u0026#34;; import ListPage from \u0026#34;../components/ListPage\u0026#34;; export default class Home extends React.Component { constructor() { super(); this.state = { movies: [], key: \u0026#34;\u0026#34;, }; } static navigationOptions = { tabBarLabel: \u0026#34;主页\u0026#34;, }; keyChange = (key) =\u0026gt; { this.setState({ key, }); this.getSearch(); }; getSearch = () =\u0026gt; { search(this.state.key).then((rsp) =\u0026gt; { this.setState({ movies: rsp.subjects, }); }); }; render() { return ( \u0026lt;View\u0026gt; \u0026lt;SearchBar onChangeText={this.keyChange} placeholder=\u0026#34;输入关键字搜索\u0026#34; /\u0026gt; \u0026lt;ListPage movies={this.state.movies} loadData={this.getSearch} navigation={this.props.navigation} /\u0026gt; \u0026lt;/View\u0026gt; ); } } 5、导航实现 import React from \u0026#34;react\u0026#34;; import { TabNavigator, StackNavigator } from \u0026#34;react-navigation\u0026#34;; import Home from \u0026#34;./views/Home\u0026#34;; import Top250 from \u0026#34;./views/Top250\u0026#34;; import UsBox from \u0026#34;./views/UsBox\u0026#34;; import Showing from \u0026#34;./views/Showing\u0026#34;; import ComingSoon from \u0026#34;./views/ComingSoon\u0026#34;; import MovieInfo from \u0026#34;./views/MovieInfo\u0026#34;; import ActorInfo from \u0026#34;./views/ActorInfo\u0026#34;; export default MyApp = StackNavigator( { FirstScreen: { screen: TabNavigator( { Top250: { screen: Top250, }, UsBox: { screen: UsBox, }, Home: { screen: Home, }, Showing: { screen: Showing, }, ComingSoon: { screen: ComingSoon, }, }, { tabBarPosition: \u0026#34;bottom\u0026#34;, animationEnabled: true, lazy: true, initialRouteName: \u0026#34;Home\u0026#34;, } ), }, MovieInfo: { screen: MovieInfo, }, ActorInfo: { screen: ActorInfo, }, }, { headerMode: \u0026#34;none\u0026#34;, } ); ","date":"2019-09-18T20:51:20+08:00","image":"https://picsum.photos/seed/c2c7c029452b45aa8117a63cd653cdb4/4096/2160","permalink":"https://jo-hnny.github.io/p/%E5%88%9D%E6%8E%A2react-native/","title":"初探react Native"},{"content":"1、得到一个固定长度的非空的数组 比如我需要一个数组，元素是 1-10，首先我不想用直接手写一个数组，以前的实现方式:\nnew Array(10).fill(0).map((_, index) =\u0026gt; ++index); 为什么要加个 fill 呢，是因为 Array 构造函数返回的数组都是空位，就是什么都没有，连 undefined 都不是，map 方法不生效。 es6 扩展运算符的写法：\n[...new Array(10)].map((_, index) =\u0026gt; ++index); 扩展运算符会将空位都变成 undefined。\n2、es6 - Symbol 好像没什么好说的，最大的特点就是唯一性，但是也感觉到了一个问题，用它作为属性名的时候，要想取出来必须使用这个 Symbol 值，那么跨模块的时候，其它模块想取出这个值，还必须把这个 Symbol 值抛出去。\n又看到了Symbol.for()，好像能解决问题，但是总感觉哪不对\n3、getter 与 setter getter var obj = { log: [\u0026#34;example\u0026#34;, \u0026#34;test\u0026#34;], get latest() { if (this.log.length == 0) return undefined; return this.log[this.log.length - 1]; }, }; console.log(obj.latest); // \u0026#34;test\u0026#34;. var obj = { log: [\u0026#34;example\u0026#34;, \u0026#34;test\u0026#34;], latest() { if (this.log.length == 0) return undefined; return this.log[this.log.length - 1]; }, }; console.log(obj.latest()); setter var language = { set current(name) { this.log.push(name); }, log: [], }; language.current = \u0026#34;EN\u0026#34;; console.log(language.log); // [\u0026#39;EN\u0026#39;]  language.current = \u0026#34;FA\u0026#34;; console.log(language.log); // [\u0026#39;EN\u0026#39;, \u0026#39;FA\u0026#39;] var language = { current(name) { this.log.push(name); }, log: [], }; language.current(\u0026#34;EN\u0026#34;); console.log(language.log); // [\u0026#39;EN\u0026#39;]  language.current(\u0026#34;FA\u0026#34;); console.log(language.log); // [\u0026#39;EN\u0026#39;, \u0026#39;FA\u0026#39;] 重要的是当取值、赋值时你可以通过get函数以及set函数做一些其它的事。\n4、连续赋值存在的问题 let a = {}; let b = a; a.x = a = { n: 1 }; console.log(a.x); // undefined console.log(b.x); // {n: 1} 不知道这段代码的结果有没有一点出人意料，原因就是在赋值之前，就已经确定了内存中的地址，然后才开始赋值\n5、yield*的用法 看到了一个数组拍平的问题,其中yield*的作用就像是一个对其它 generator 函数的代理。\nconst a = [1, [[2], 3, 4], 5]; function* flatten2(arr) { for (item of arr) { Array.isArray(item) ? yield* flatten2(item) : yield item; } } const numbers = flatten2(a); console.log(numbers.next()); // 1  console.log(numbers.next()); // 2 6、实现自己的防抖函数 const a = () =\u0026gt; console.log(\u0026#34;a\u0026#34;); const choke = (fn, timeout = 0) =\u0026gt; { let start = 0; return () =\u0026gt; { const now = Date.now(); if (now - start \u0026gt; timeout) { start = now; return fn(); } }; }; const b = choke(a, 1000); b(); b(); 7、自定义一个事件类 class Event { constructor() { this.stack = {}; } emit(eName, ...args) { if (this.stack[eName]) this.stack[eName].forEach((cb) =\u0026gt; cb(...args)); } on(eName, cb) { if (this.stack[eName]) return this.stack[eName].push(cb); this.stack[eName] = [cb]; } off(eName, cb) { if (!this.stack[eName]) return; if (!cb) return delete this.stack[eName]; this.stack[eName].forEach((acb, index) =\u0026gt; { if (acb === cb) delete this.stack[eName][index]; }); } } const e = new Event(); e.on(\u0026#34;click\u0026#34;, (a) =\u0026gt; console.log(a)); e.emit(\u0026#34;click\u0026#34;, 123); 8、egg 配合 dockers 使用时要把 scripts start 中的\u0026ndash;demon 去掉。 ","date":"2019-09-18T20:50:02+08:00","image":"https://picsum.photos/seed/a0fe4c2dd95249899623f35136c16e97/4096/2160","permalink":"https://jo-hnny.github.io/p/%E9%9A%8F%E7%AC%94/","title":"随笔"},{"content":"前些天项目需求要实现屏幕取词，通过我的调研使用 range api 实现了这个功能，后来我又分析了扇贝的开放 api，了解了扇贝的屏幕取词实现方式，在这里总结一下。\nRange 方式 这是我在项目中实现屏幕取词的方式，其关键在于document.caretRangeFromPoint(float x, float y)方法，这个方法接收一个坐标，通过这个坐标生成一个 range 对象，通过这个 range 对象可以获取到当前点击的文本内容，以及当前点击的文本位置，我把这个实现方式封装成了一个包theword，已经上传到了 npm 仓库，下边通过代码分析一下：\nexport default (event, regexp = /[a-zA-Z\u0026#39;’]/) =\u0026gt; { // 监测一个字符是否是构成单词的字符  const isWord = (str) =\u0026gt; str \u0026amp;\u0026amp; regexp.test(str); const { clientX, clientY } = event; // 通过一个点生成range  const range = document.caretRangeFromPoint(clientX, clientY); // 点击的dome节点的文本内容  const data = range.startContainer.data; // 点击的字符在文本中的位置  const point = range.startOffset; if (!isWord(data[point])) return; let j = point - 1; let k = point + 1; let wordArr = [data[point]]; // 从点击位置向前寻找符合构成单词条件的字符，直到遇到非构成单词的字符  while (isWord(data[j])) { wordArr.unshift(data[j]); j--; } // 重新设置range开始的位置  range.setStart(range.startContainer, j + 1); // // 从点击位置向后寻找符合构成单词条件的字符，直到遇到非构成单词的字符  while (isWord(data[k])) { wordArr.push(data[k]); k++; } // 重新设置range结束的位置  range.setEnd(range.endContainer, k); // 获取当前window下的选区，并且清空所有选区  const s = window.getSelection(); s.removeAllRanges(); // 一开始使用了原始拖蓝效果表示选中，但是可定制性差，达不到UI想要的效果，所以注释掉了  // s.addRange(range)  const word = wordArr.join(\u0026#34;\u0026#34;); // 获取range的位置信息  const rect = range.getBoundingClientRect(); return { word, rect, }; }; 最后通过这个方法，我们成功的获取到了点击的单词，以及该单词的位置信息，包括宽高、距离屏幕的位置，最后通过一个定位的 div 覆盖掉原先的单词，实现了选中效果。\n分割文章的方式 这个其实就是拿到全篇文章，用空格将全文分割成单词构成的数组，然后循环生成 dom，给每个 dom 绑定点击事件；我一开始也是这么想的，但是当时觉得这个方法太暴力了，并且可能带来性能问题，当然我现在还是觉得它很暴力，但是它足够简单。\n词组查询 扇贝的实现方式是还有一个接口会返回词组在文章中的位置，位置的表示是以该词组的起始单词和结束单词分别是第几个单词确定的，按照我的方法假如要实现词组查询功能，也是需要这么一个词组的接口，但是位置信息就应该是字符位置了。\n","date":"2019-09-18T20:47:53+08:00","image":"https://picsum.photos/seed/72184b95064c4307b47f42fcf2c85619/4096/2160","permalink":"https://jo-hnny.github.io/p/web%E5%B1%8F%E5%B9%95%E5%8F%96%E8%AF%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","title":"Web屏幕取词实现方式"}]